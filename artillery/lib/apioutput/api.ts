/* tslint:disable */
/* eslint-disable */
/**
 * Bloom API
 * The API for Bloom
 *
 * The version of the OpenAPI document: 2.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import type { Configuration } from "./configuration";
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from "axios";
import globalAxios from "axios";
// Some imports not used depending on template conditions
// @ts-ignore
import {
  DUMMY_BASE_URL,
  assertParamExists,
  setApiKeyToObject,
  setBasicAuthToObject,
  setBearerAuthToObject,
  setOAuthToObject,
  setSearchParams,
  serializeDataIfNeeded,
  toPathString,
  createRequestFunction,
} from "./common";
import type { RequestArgs } from "./base";
// @ts-ignore
import {
  BASE_PATH,
  COLLECTION_FORMATS,
  BaseAPI,
  RequiredError,
  operationServerMap,
} from "./base";

/**
 *
 * @export
 * @interface Accessibility
 */
export interface Accessibility {
  /**
   *
   * @type {string}
   * @memberof Accessibility
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof Accessibility
   */
  createdAt: string;
  /**
   *
   * @type {string}
   * @memberof Accessibility
   */
  updatedAt: string;
  /**
   *
   * @type {boolean}
   * @memberof Accessibility
   */
  mobility?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof Accessibility
   */
  vision?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof Accessibility
   */
  hearing?: boolean;
}
/**
 *
 * @export
 * @interface AccessibilityUpdate
 */
export interface AccessibilityUpdate {
  /**
   *
   * @type {boolean}
   * @memberof AccessibilityUpdate
   */
  mobility?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof AccessibilityUpdate
   */
  vision?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof AccessibilityUpdate
   */
  hearing?: boolean;
}
/**
 *
 * @export
 * @interface Address
 */
export interface Address {
  /**
   *
   * @type {string}
   * @memberof Address
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof Address
   */
  createdAt: string;
  /**
   *
   * @type {string}
   * @memberof Address
   */
  updatedAt: string;
  /**
   *
   * @type {string}
   * @memberof Address
   */
  placeName?: string;
  /**
   *
   * @type {string}
   * @memberof Address
   */
  city: string;
  /**
   *
   * @type {string}
   * @memberof Address
   */
  county?: string;
  /**
   *
   * @type {string}
   * @memberof Address
   */
  state: string;
  /**
   *
   * @type {string}
   * @memberof Address
   */
  street: string;
  /**
   *
   * @type {string}
   * @memberof Address
   */
  street2?: string;
  /**
   *
   * @type {string}
   * @memberof Address
   */
  zipCode: string;
  /**
   *
   * @type {number}
   * @memberof Address
   */
  latitude?: number;
  /**
   *
   * @type {number}
   * @memberof Address
   */
  longitude?: number;
}
/**
 *
 * @export
 * @interface AddressCreate
 */
export interface AddressCreate {
  /**
   *
   * @type {string}
   * @memberof AddressCreate
   */
  placeName?: string;
  /**
   *
   * @type {string}
   * @memberof AddressCreate
   */
  city: string;
  /**
   *
   * @type {string}
   * @memberof AddressCreate
   */
  county?: string;
  /**
   *
   * @type {string}
   * @memberof AddressCreate
   */
  state: string;
  /**
   *
   * @type {string}
   * @memberof AddressCreate
   */
  street: string;
  /**
   *
   * @type {string}
   * @memberof AddressCreate
   */
  street2?: string;
  /**
   *
   * @type {string}
   * @memberof AddressCreate
   */
  zipCode: string;
  /**
   *
   * @type {number}
   * @memberof AddressCreate
   */
  latitude?: number;
  /**
   *
   * @type {number}
   * @memberof AddressCreate
   */
  longitude?: number;
}
/**
 *
 * @export
 * @interface AddressInput
 */
export interface AddressInput {
  /**
   *
   * @type {InputType}
   * @memberof AddressInput
   */
  type: InputType;
  /**
   *
   * @type {string}
   * @memberof AddressInput
   */
  key: string;
  /**
   *
   * @type {AddressCreate}
   * @memberof AddressInput
   */
  value: AddressCreate;
}

/**
 *
 * @export
 * @interface AfsMeta
 */
export interface AfsMeta {
  /**
   *
   * @type {number}
   * @memberof AfsMeta
   */
  totalCount?: number;
  /**
   *
   * @type {number}
   * @memberof AfsMeta
   */
  totalResolvedCount?: number;
  /**
   *
   * @type {number}
   * @memberof AfsMeta
   */
  totalPendingCount?: number;
  /**
   *
   * @type {number}
   * @memberof AfsMeta
   */
  totalNamePendingCount?: number;
  /**
   *
   * @type {number}
   * @memberof AfsMeta
   */
  totalEmailPendingCount?: number;
}
/**
 *
 * @export
 * @interface AfsResolve
 */
export interface AfsResolve {
  /**
   *
   * @type {string}
   * @memberof AfsResolve
   */
  afsId: string;
  /**
   *
   * @type {FlaggedSetStatusEnum}
   * @memberof AfsResolve
   */
  status: FlaggedSetStatusEnum;
  /**
   *
   * @type {Array<IdDTO>}
   * @memberof AfsResolve
   */
  applications: Array<IdDTO>;
}

/**
 *
 * @export
 * @enum {string}
 */

export const AfsView = {
  Pending: "pending",
  PendingNameAndDoB: "pendingNameAndDoB",
  PendingEmail: "pendingEmail",
  Resolved: "resolved",
} as const;

export type AfsView = (typeof AfsView)[keyof typeof AfsView];

/**
 *
 * @export
 * @interface AlternateContact
 */
export interface AlternateContact {
  /**
   *
   * @type {string}
   * @memberof AlternateContact
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof AlternateContact
   */
  createdAt: string;
  /**
   *
   * @type {string}
   * @memberof AlternateContact
   */
  updatedAt: string;
  /**
   *
   * @type {AlternateContactRelationship}
   * @memberof AlternateContact
   */
  type?: AlternateContactRelationship;
  /**
   *
   * @type {string}
   * @memberof AlternateContact
   */
  otherType?: string;
  /**
   *
   * @type {string}
   * @memberof AlternateContact
   */
  firstName?: string;
  /**
   *
   * @type {string}
   * @memberof AlternateContact
   */
  lastName?: string;
  /**
   *
   * @type {string}
   * @memberof AlternateContact
   */
  agency?: string;
  /**
   *
   * @type {string}
   * @memberof AlternateContact
   */
  phoneNumber?: string;
  /**
   *
   * @type {string}
   * @memberof AlternateContact
   */
  emailAddress?: string;
  /**
   *
   * @type {Address}
   * @memberof AlternateContact
   */
  address: Address;
}

/**
 *
 * @export
 * @enum {string}
 */

export const AlternateContactRelationship = {
  FamilyMember: "familyMember",
  Friend: "friend",
  CaseManager: "caseManager",
  Other: "other",
  NoContact: "noContact",
} as const;

export type AlternateContactRelationship =
  (typeof AlternateContactRelationship)[keyof typeof AlternateContactRelationship];

/**
 *
 * @export
 * @interface AlternateContactUpdate
 */
export interface AlternateContactUpdate {
  /**
   *
   * @type {AlternateContactRelationship}
   * @memberof AlternateContactUpdate
   */
  type?: AlternateContactRelationship;
  /**
   *
   * @type {string}
   * @memberof AlternateContactUpdate
   */
  otherType?: string;
  /**
   *
   * @type {string}
   * @memberof AlternateContactUpdate
   */
  firstName?: string;
  /**
   *
   * @type {string}
   * @memberof AlternateContactUpdate
   */
  lastName?: string;
  /**
   *
   * @type {string}
   * @memberof AlternateContactUpdate
   */
  agency?: string;
  /**
   *
   * @type {string}
   * @memberof AlternateContactUpdate
   */
  phoneNumber?: string;
  /**
   *
   * @type {string}
   * @memberof AlternateContactUpdate
   */
  emailAddress?: string;
  /**
   *
   * @type {AddressCreate}
   * @memberof AlternateContactUpdate
   */
  address: AddressCreate;
}

/**
 *
 * @export
 * @interface AmiChart
 */
export interface AmiChart {
  /**
   *
   * @type {string}
   * @memberof AmiChart
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof AmiChart
   */
  createdAt: string;
  /**
   *
   * @type {string}
   * @memberof AmiChart
   */
  updatedAt: string;
  /**
   *
   * @type {Array<AmiChartItem>}
   * @memberof AmiChart
   */
  items: Array<AmiChartItem>;
  /**
   *
   * @type {string}
   * @memberof AmiChart
   */
  name: string;
  /**
   *
   * @type {IdDTO}
   * @memberof AmiChart
   */
  jurisdictions: IdDTO;
}
/**
 *
 * @export
 * @interface AmiChartCreate
 */
export interface AmiChartCreate {
  /**
   *
   * @type {Array<AmiChartItem>}
   * @memberof AmiChartCreate
   */
  items: Array<AmiChartItem>;
  /**
   *
   * @type {string}
   * @memberof AmiChartCreate
   */
  name: string;
  /**
   *
   * @type {IdDTO}
   * @memberof AmiChartCreate
   */
  jurisdictions: IdDTO;
}
/**
 *
 * @export
 * @interface AmiChartImportDTO
 */
export interface AmiChartImportDTO {
  /**
   *
   * @type {string}
   * @memberof AmiChartImportDTO
   */
  values: string;
  /**
   *
   * @type {string}
   * @memberof AmiChartImportDTO
   */
  name: string;
  /**
   *
   * @type {string}
   * @memberof AmiChartImportDTO
   */
  jurisdictionId: string;
}
/**
 *
 * @export
 * @interface AmiChartItem
 */
export interface AmiChartItem {
  /**
   *
   * @type {number}
   * @memberof AmiChartItem
   */
  percentOfAmi: number;
  /**
   *
   * @type {number}
   * @memberof AmiChartItem
   */
  householdSize: number;
  /**
   *
   * @type {number}
   * @memberof AmiChartItem
   */
  income: number;
}
/**
 *
 * @export
 * @interface AmiChartQueryParams
 */
export interface AmiChartQueryParams {
  /**
   *
   * @type {string}
   * @memberof AmiChartQueryParams
   */
  jurisdictionId?: string;
}
/**
 *
 * @export
 * @interface AmiChartUpdate
 */
export interface AmiChartUpdate {
  /**
   *
   * @type {string}
   * @memberof AmiChartUpdate
   */
  id: string;
  /**
   *
   * @type {Array<AmiChartItem>}
   * @memberof AmiChartUpdate
   */
  items: Array<AmiChartItem>;
  /**
   *
   * @type {string}
   * @memberof AmiChartUpdate
   */
  name: string;
}
/**
 *
 * @export
 * @interface Applicant
 */
export interface Applicant {
  /**
   *
   * @type {string}
   * @memberof Applicant
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof Applicant
   */
  createdAt: string;
  /**
   *
   * @type {string}
   * @memberof Applicant
   */
  updatedAt: string;
  /**
   *
   * @type {string}
   * @memberof Applicant
   */
  firstName?: string;
  /**
   *
   * @type {string}
   * @memberof Applicant
   */
  middleName?: string;
  /**
   *
   * @type {string}
   * @memberof Applicant
   */
  lastName?: string;
  /**
   *
   * @type {string}
   * @memberof Applicant
   */
  birthMonth?: string;
  /**
   *
   * @type {string}
   * @memberof Applicant
   */
  birthDay?: string;
  /**
   *
   * @type {string}
   * @memberof Applicant
   */
  birthYear?: string;
  /**
   *
   * @type {string}
   * @memberof Applicant
   */
  emailAddress?: string;
  /**
   *
   * @type {boolean}
   * @memberof Applicant
   */
  noEmail?: boolean;
  /**
   *
   * @type {string}
   * @memberof Applicant
   */
  phoneNumber?: string;
  /**
   *
   * @type {string}
   * @memberof Applicant
   */
  phoneNumberType?: string;
  /**
   *
   * @type {boolean}
   * @memberof Applicant
   */
  noPhone?: boolean;
  /**
   *
   * @type {YesNoEnum}
   * @memberof Applicant
   */
  workInRegion?: YesNoEnum;
  /**
   *
   * @type {Address}
   * @memberof Applicant
   */
  applicantWorkAddress: Address;
  /**
   *
   * @type {Address}
   * @memberof Applicant
   */
  applicantAddress: Address;
}

/**
 *
 * @export
 * @interface ApplicantUpdate
 */
export interface ApplicantUpdate {
  /**
   *
   * @type {string}
   * @memberof ApplicantUpdate
   */
  firstName?: string;
  /**
   *
   * @type {string}
   * @memberof ApplicantUpdate
   */
  middleName?: string;
  /**
   *
   * @type {string}
   * @memberof ApplicantUpdate
   */
  lastName?: string;
  /**
   *
   * @type {string}
   * @memberof ApplicantUpdate
   */
  birthMonth?: string;
  /**
   *
   * @type {string}
   * @memberof ApplicantUpdate
   */
  birthDay?: string;
  /**
   *
   * @type {string}
   * @memberof ApplicantUpdate
   */
  birthYear?: string;
  /**
   *
   * @type {string}
   * @memberof ApplicantUpdate
   */
  emailAddress?: string;
  /**
   *
   * @type {boolean}
   * @memberof ApplicantUpdate
   */
  noEmail?: boolean;
  /**
   *
   * @type {string}
   * @memberof ApplicantUpdate
   */
  phoneNumber?: string;
  /**
   *
   * @type {string}
   * @memberof ApplicantUpdate
   */
  phoneNumberType?: string;
  /**
   *
   * @type {boolean}
   * @memberof ApplicantUpdate
   */
  noPhone?: boolean;
  /**
   *
   * @type {YesNoEnum}
   * @memberof ApplicantUpdate
   */
  workInRegion?: YesNoEnum;
  /**
   *
   * @type {AddressCreate}
   * @memberof ApplicantUpdate
   */
  applicantAddress: AddressCreate;
  /**
   *
   * @type {AddressCreate}
   * @memberof ApplicantUpdate
   */
  applicantWorkAddress: AddressCreate;
}

/**
 *
 * @export
 * @interface Application
 */
export interface Application {
  /**
   *
   * @type {string}
   * @memberof Application
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof Application
   */
  createdAt: string;
  /**
   *
   * @type {string}
   * @memberof Application
   */
  updatedAt: string;
  /**
   *
   * @type {string}
   * @memberof Application
   */
  deletedAt?: string;
  /**
   *
   * @type {string}
   * @memberof Application
   */
  appUrl?: string;
  /**
   *
   * @type {boolean}
   * @memberof Application
   */
  additionalPhone?: boolean;
  /**
   *
   * @type {string}
   * @memberof Application
   */
  additionalPhoneNumber?: string;
  /**
   *
   * @type {string}
   * @memberof Application
   */
  additionalPhoneNumberType?: string;
  /**
   *
   * @type {Array<string>}
   * @memberof Application
   */
  contactPreferences: Array<string>;
  /**
   *
   * @type {number}
   * @memberof Application
   */
  householdSize: number;
  /**
   *
   * @type {string}
   * @memberof Application
   */
  housingStatus?: string;
  /**
   *
   * @type {boolean}
   * @memberof Application
   */
  sendMailToMailingAddress?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof Application
   */
  householdExpectingChanges?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof Application
   */
  householdStudent?: boolean;
  /**
   *
   * @type {Array<string>}
   * @memberof Application
   */
  incomeVouchers?: Array<string>;
  /**
   *
   * @type {string}
   * @memberof Application
   */
  income?: string;
  /**
   *
   * @type {IncomePeriodEnum}
   * @memberof Application
   */
  incomePeriod?: IncomePeriodEnum;
  /**
   *
   * @type {ApplicationStatusEnum}
   * @memberof Application
   */
  status: ApplicationStatusEnum;
  /**
   *
   * @type {LanguagesEnum}
   * @memberof Application
   */
  language?: LanguagesEnum;
  /**
   *
   * @type {boolean}
   * @memberof Application
   */
  acceptedTerms?: boolean;
  /**
   *
   * @type {ApplicationSubmissionTypeEnum}
   * @memberof Application
   */
  submissionType: ApplicationSubmissionTypeEnum;
  /**
   *
   * @type {string}
   * @memberof Application
   */
  submissionDate?: string;
  /**
   *
   * @type {string}
   * @memberof Application
   */
  receivedBy?: string;
  /**
   *
   * @type {string}
   * @memberof Application
   */
  receivedAt?: string;
  /**
   *
   * @type {boolean}
   * @memberof Application
   */
  markedAsDuplicate: boolean;
  /**
   *
   * @type {boolean}
   * @memberof Application
   */
  flagged?: boolean;
  /**
   *
   * @type {string}
   * @memberof Application
   */
  confirmationCode: string;
  /**
   *
   * @type {ApplicationReviewStatusEnum}
   * @memberof Application
   */
  reviewStatus?: ApplicationReviewStatusEnum;
  /**
   *
   * @type {Address}
   * @memberof Application
   */
  applicationsMailingAddress: Address;
  /**
   *
   * @type {Address}
   * @memberof Application
   */
  applicationsAlternateAddress: Address;
  /**
   *
   * @type {Accessibility}
   * @memberof Application
   */
  accessibility: Accessibility;
  /**
   *
   * @type {Demographic}
   * @memberof Application
   */
  demographics: Demographic;
  /**
   *
   * @type {Array<UnitType>}
   * @memberof Application
   */
  preferredUnitTypes: Array<UnitType>;
  /**
   *
   * @type {Applicant}
   * @memberof Application
   */
  applicant: Applicant;
  /**
   *
   * @type {AlternateContact}
   * @memberof Application
   */
  alternateContact: AlternateContact;
  /**
   *
   * @type {Array<HouseholdMember>}
   * @memberof Application
   */
  householdMember: Array<HouseholdMember>;
  /**
   *
   * @type {Array<ApplicationMultiselectQuestion>}
   * @memberof Application
   */
  preferences?: Array<ApplicationMultiselectQuestion>;
  /**
   *
   * @type {Array<ApplicationMultiselectQuestion>}
   * @memberof Application
   */
  programs?: Array<ApplicationMultiselectQuestion>;
  /**
   *
   * @type {IdDTO}
   * @memberof Application
   */
  listings: IdDTO;
  /**
   *
   * @type {Array<ApplicationLotteryPosition>}
   * @memberof Application
   */
  applicationLotteryPositions: Array<ApplicationLotteryPosition>;
}

/**
 *
 * @export
 * @enum {string}
 */

export const ApplicationAddressTypeEnum = {
  LeasingAgent: "leasingAgent",
} as const;

export type ApplicationAddressTypeEnum =
  (typeof ApplicationAddressTypeEnum)[keyof typeof ApplicationAddressTypeEnum];

/**
 *
 * @export
 * @interface ApplicationCreate
 */
export interface ApplicationCreate {
  /**
   *
   * @type {string}
   * @memberof ApplicationCreate
   */
  appUrl?: string;
  /**
   *
   * @type {boolean}
   * @memberof ApplicationCreate
   */
  additionalPhone?: boolean;
  /**
   *
   * @type {string}
   * @memberof ApplicationCreate
   */
  additionalPhoneNumber?: string;
  /**
   *
   * @type {string}
   * @memberof ApplicationCreate
   */
  additionalPhoneNumberType?: string;
  /**
   *
   * @type {Array<string>}
   * @memberof ApplicationCreate
   */
  contactPreferences: Array<string>;
  /**
   *
   * @type {number}
   * @memberof ApplicationCreate
   */
  householdSize: number;
  /**
   *
   * @type {string}
   * @memberof ApplicationCreate
   */
  housingStatus?: string;
  /**
   *
   * @type {boolean}
   * @memberof ApplicationCreate
   */
  sendMailToMailingAddress?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof ApplicationCreate
   */
  householdExpectingChanges?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof ApplicationCreate
   */
  householdStudent?: boolean;
  /**
   *
   * @type {Array<string>}
   * @memberof ApplicationCreate
   */
  incomeVouchers?: Array<string>;
  /**
   *
   * @type {string}
   * @memberof ApplicationCreate
   */
  income?: string;
  /**
   *
   * @type {IncomePeriodEnum}
   * @memberof ApplicationCreate
   */
  incomePeriod?: IncomePeriodEnum;
  /**
   *
   * @type {ApplicationStatusEnum}
   * @memberof ApplicationCreate
   */
  status: ApplicationStatusEnum;
  /**
   *
   * @type {LanguagesEnum}
   * @memberof ApplicationCreate
   */
  language?: LanguagesEnum;
  /**
   *
   * @type {boolean}
   * @memberof ApplicationCreate
   */
  acceptedTerms?: boolean;
  /**
   *
   * @type {ApplicationSubmissionTypeEnum}
   * @memberof ApplicationCreate
   */
  submissionType: ApplicationSubmissionTypeEnum;
  /**
   *
   * @type {string}
   * @memberof ApplicationCreate
   */
  submissionDate?: string;
  /**
   *
   * @type {string}
   * @memberof ApplicationCreate
   */
  receivedBy?: string;
  /**
   *
   * @type {string}
   * @memberof ApplicationCreate
   */
  receivedAt?: string;
  /**
   *
   * @type {ApplicationReviewStatusEnum}
   * @memberof ApplicationCreate
   */
  reviewStatus?: ApplicationReviewStatusEnum;
  /**
   *
   * @type {Array<ApplicationMultiselectQuestion>}
   * @memberof ApplicationCreate
   */
  preferences?: Array<ApplicationMultiselectQuestion>;
  /**
   *
   * @type {Array<ApplicationMultiselectQuestion>}
   * @memberof ApplicationCreate
   */
  programs?: Array<ApplicationMultiselectQuestion>;
  /**
   *
   * @type {IdDTO}
   * @memberof ApplicationCreate
   */
  listings: IdDTO;
  /**
   *
   * @type {ApplicantUpdate}
   * @memberof ApplicationCreate
   */
  applicant: ApplicantUpdate;
  /**
   *
   * @type {AddressCreate}
   * @memberof ApplicationCreate
   */
  applicationsMailingAddress: AddressCreate;
  /**
   *
   * @type {AddressCreate}
   * @memberof ApplicationCreate
   */
  applicationsAlternateAddress: AddressCreate;
  /**
   *
   * @type {AlternateContactUpdate}
   * @memberof ApplicationCreate
   */
  alternateContact: AlternateContactUpdate;
  /**
   *
   * @type {AccessibilityUpdate}
   * @memberof ApplicationCreate
   */
  accessibility: AccessibilityUpdate;
  /**
   *
   * @type {DemographicUpdate}
   * @memberof ApplicationCreate
   */
  demographics: DemographicUpdate;
  /**
   *
   * @type {Array<HouseholdMemberUpdate>}
   * @memberof ApplicationCreate
   */
  householdMember: Array<HouseholdMemberUpdate>;
  /**
   *
   * @type {Array<IdDTO>}
   * @memberof ApplicationCreate
   */
  preferredUnitTypes: Array<IdDTO>;
}

/**
 *
 * @export
 * @interface ApplicationCsvQueryParams
 */
export interface ApplicationCsvQueryParams {
  /**
   *
   * @type {string}
   * @memberof ApplicationCsvQueryParams
   */
  id: string;
  /**
   *
   * @type {boolean}
   * @memberof ApplicationCsvQueryParams
   */
  includeDemographics?: boolean;
  /**
   *
   * @type {string}
   * @memberof ApplicationCsvQueryParams
   */
  timeZone?: string;
}
/**
 *
 * @export
 * @interface ApplicationFlaggedSet
 */
export interface ApplicationFlaggedSet {
  /**
   *
   * @type {string}
   * @memberof ApplicationFlaggedSet
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof ApplicationFlaggedSet
   */
  createdAt: string;
  /**
   *
   * @type {string}
   * @memberof ApplicationFlaggedSet
   */
  updatedAt: string;
  /**
   *
   * @type {IdDTO}
   * @memberof ApplicationFlaggedSet
   */
  resolvingUser: IdDTO;
  /**
   *
   * @type {IdDTO}
   * @memberof ApplicationFlaggedSet
   */
  listing: IdDTO;
  /**
   *
   * @type {RuleEnum}
   * @memberof ApplicationFlaggedSet
   */
  rule: RuleEnum;
  /**
   *
   * @type {string}
   * @memberof ApplicationFlaggedSet
   */
  ruleKey: string;
  /**
   *
   * @type {string}
   * @memberof ApplicationFlaggedSet
   */
  resolvedTime?: string;
  /**
   *
   * @type {string}
   * @memberof ApplicationFlaggedSet
   */
  listingId: string;
  /**
   *
   * @type {boolean}
   * @memberof ApplicationFlaggedSet
   */
  showConfirmationAlert: boolean;
  /**
   *
   * @type {FlaggedSetStatusEnum}
   * @memberof ApplicationFlaggedSet
   */
  status: FlaggedSetStatusEnum;
  /**
   *
   * @type {Array<Application>}
   * @memberof ApplicationFlaggedSet
   */
  applications: Array<Application>;
}

/**
 *
 * @export
 * @interface ApplicationFlaggedSetPaginationMeta
 */
export interface ApplicationFlaggedSetPaginationMeta {
  /**
   *
   * @type {number}
   * @memberof ApplicationFlaggedSetPaginationMeta
   */
  currentPage: number;
  /**
   *
   * @type {number}
   * @memberof ApplicationFlaggedSetPaginationMeta
   */
  itemCount: number;
  /**
   *
   * @type {number}
   * @memberof ApplicationFlaggedSetPaginationMeta
   */
  itemsPerPage: number;
  /**
   *
   * @type {number}
   * @memberof ApplicationFlaggedSetPaginationMeta
   */
  totalItems: number;
  /**
   *
   * @type {number}
   * @memberof ApplicationFlaggedSetPaginationMeta
   */
  totalPages: number;
  /**
   *
   * @type {number}
   * @memberof ApplicationFlaggedSetPaginationMeta
   */
  totalFlagged: number;
}
/**
 *
 * @export
 * @interface ApplicationLotteryPosition
 */
export interface ApplicationLotteryPosition {
  /**
   *
   * @type {string}
   * @memberof ApplicationLotteryPosition
   */
  listingId: string;
  /**
   *
   * @type {string}
   * @memberof ApplicationLotteryPosition
   */
  applicationId: string;
  /**
   *
   * @type {string}
   * @memberof ApplicationLotteryPosition
   */
  multiselectQuestionId: string;
  /**
   *
   * @type {number}
   * @memberof ApplicationLotteryPosition
   */
  ordinal: number;
}
/**
 *
 * @export
 * @interface ApplicationLotteryTotal
 */
export interface ApplicationLotteryTotal {
  /**
   *
   * @type {string}
   * @memberof ApplicationLotteryTotal
   */
  listingId: string;
  /**
   *
   * @type {string}
   * @memberof ApplicationLotteryTotal
   */
  multiselectQuestionId?: string;
  /**
   *
   * @type {number}
   * @memberof ApplicationLotteryTotal
   */
  total: number;
}
/**
 *
 * @export
 * @interface ApplicationMethod
 */
export interface ApplicationMethod {
  /**
   *
   * @type {string}
   * @memberof ApplicationMethod
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof ApplicationMethod
   */
  createdAt: string;
  /**
   *
   * @type {string}
   * @memberof ApplicationMethod
   */
  updatedAt: string;
  /**
   *
   * @type {ApplicationMethodsTypeEnum}
   * @memberof ApplicationMethod
   */
  type: ApplicationMethodsTypeEnum;
  /**
   *
   * @type {string}
   * @memberof ApplicationMethod
   */
  label?: string;
  /**
   *
   * @type {string}
   * @memberof ApplicationMethod
   */
  externalReference?: string;
  /**
   *
   * @type {boolean}
   * @memberof ApplicationMethod
   */
  acceptsPostmarkedApplications?: boolean;
  /**
   *
   * @type {string}
   * @memberof ApplicationMethod
   */
  phoneNumber?: string;
  /**
   *
   * @type {Array<PaperApplication>}
   * @memberof ApplicationMethod
   */
  paperApplications?: Array<PaperApplication>;
}

/**
 *
 * @export
 * @interface ApplicationMethodCreate
 */
export interface ApplicationMethodCreate {
  /**
   *
   * @type {ApplicationMethodsTypeEnum}
   * @memberof ApplicationMethodCreate
   */
  type: ApplicationMethodsTypeEnum;
  /**
   *
   * @type {string}
   * @memberof ApplicationMethodCreate
   */
  label?: string;
  /**
   *
   * @type {string}
   * @memberof ApplicationMethodCreate
   */
  externalReference?: string;
  /**
   *
   * @type {boolean}
   * @memberof ApplicationMethodCreate
   */
  acceptsPostmarkedApplications?: boolean;
  /**
   *
   * @type {string}
   * @memberof ApplicationMethodCreate
   */
  phoneNumber?: string;
  /**
   *
   * @type {Array<PaperApplicationCreate>}
   * @memberof ApplicationMethodCreate
   */
  paperApplications?: Array<PaperApplicationCreate>;
}

/**
 *
 * @export
 * @enum {string}
 */

export const ApplicationMethodsTypeEnum = {
  Internal: "Internal",
  FileDownload: "FileDownload",
  ExternalLink: "ExternalLink",
  PaperPickup: "PaperPickup",
  PoBox: "POBox",
  LeasingAgent: "LeasingAgent",
  Referral: "Referral",
} as const;

export type ApplicationMethodsTypeEnum =
  (typeof ApplicationMethodsTypeEnum)[keyof typeof ApplicationMethodsTypeEnum];

/**
 *
 * @export
 * @interface ApplicationMultiselectQuestion
 */
export interface ApplicationMultiselectQuestion {
  /**
   *
   * @type {string}
   * @memberof ApplicationMultiselectQuestion
   */
  multiselectQuestionId: string;
  /**
   *
   * @type {string}
   * @memberof ApplicationMultiselectQuestion
   */
  key: string;
  /**
   *
   * @type {boolean}
   * @memberof ApplicationMultiselectQuestion
   */
  claimed: boolean;
  /**
   *
   * @type {Array<ApplicationMultiselectQuestionOption>}
   * @memberof ApplicationMultiselectQuestion
   */
  options: Array<ApplicationMultiselectQuestionOption>;
}
/**
 *
 * @export
 * @interface ApplicationMultiselectQuestionOption
 */
export interface ApplicationMultiselectQuestionOption {
  /**
   *
   * @type {string}
   * @memberof ApplicationMultiselectQuestionOption
   */
  key: string;
  /**
   *
   * @type {boolean}
   * @memberof ApplicationMultiselectQuestionOption
   */
  checked: boolean;
  /**
   *
   * @type {string}
   * @memberof ApplicationMultiselectQuestionOption
   */
  mapPinPosition?: string;
  /**
   *
   * @type {Array<ApplicationMultiselectQuestionOptionExtraDataInner>}
   * @memberof ApplicationMultiselectQuestionOption
   */
  extraData?: Array<ApplicationMultiselectQuestionOptionExtraDataInner>;
}
/**
 * @type ApplicationMultiselectQuestionOptionExtraDataInner
 * @export
 */
export type ApplicationMultiselectQuestionOptionExtraDataInner =
  | AddressInput
  | BooleanInput
  | TextInput;

/**
 *
 * @export
 * @enum {string}
 */

export const ApplicationOrderByKeys = {
  FirstName: "firstName",
  LastName: "lastName",
  SubmissionDate: "submissionDate",
  CreatedAt: "createdAt",
} as const;

export type ApplicationOrderByKeys =
  (typeof ApplicationOrderByKeys)[keyof typeof ApplicationOrderByKeys];

/**
 *
 * @export
 * @enum {string}
 */

export const ApplicationReviewStatusEnum = {
  Pending: "pending",
  PendingAndValid: "pendingAndValid",
  Valid: "valid",
  Duplicate: "duplicate",
} as const;

export type ApplicationReviewStatusEnum =
  (typeof ApplicationReviewStatusEnum)[keyof typeof ApplicationReviewStatusEnum];

/**
 *
 * @export
 * @enum {string}
 */

export const ApplicationStatusEnum = {
  Draft: "draft",
  Submitted: "submitted",
  Removed: "removed",
} as const;

export type ApplicationStatusEnum =
  (typeof ApplicationStatusEnum)[keyof typeof ApplicationStatusEnum];

/**
 *
 * @export
 * @enum {string}
 */

export const ApplicationSubmissionTypeEnum = {
  Paper: "paper",
  Electronical: "electronical",
} as const;

export type ApplicationSubmissionTypeEnum =
  (typeof ApplicationSubmissionTypeEnum)[keyof typeof ApplicationSubmissionTypeEnum];

/**
 *
 * @export
 * @interface ApplicationUpdate
 */
export interface ApplicationUpdate {
  /**
   *
   * @type {string}
   * @memberof ApplicationUpdate
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof ApplicationUpdate
   */
  appUrl?: string;
  /**
   *
   * @type {boolean}
   * @memberof ApplicationUpdate
   */
  additionalPhone?: boolean;
  /**
   *
   * @type {string}
   * @memberof ApplicationUpdate
   */
  additionalPhoneNumber?: string;
  /**
   *
   * @type {string}
   * @memberof ApplicationUpdate
   */
  additionalPhoneNumberType?: string;
  /**
   *
   * @type {Array<string>}
   * @memberof ApplicationUpdate
   */
  contactPreferences: Array<string>;
  /**
   *
   * @type {number}
   * @memberof ApplicationUpdate
   */
  householdSize: number;
  /**
   *
   * @type {string}
   * @memberof ApplicationUpdate
   */
  housingStatus?: string;
  /**
   *
   * @type {boolean}
   * @memberof ApplicationUpdate
   */
  sendMailToMailingAddress?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof ApplicationUpdate
   */
  householdExpectingChanges?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof ApplicationUpdate
   */
  householdStudent?: boolean;
  /**
   *
   * @type {Array<string>}
   * @memberof ApplicationUpdate
   */
  incomeVouchers?: Array<string>;
  /**
   *
   * @type {string}
   * @memberof ApplicationUpdate
   */
  income?: string;
  /**
   *
   * @type {IncomePeriodEnum}
   * @memberof ApplicationUpdate
   */
  incomePeriod?: IncomePeriodEnum;
  /**
   *
   * @type {ApplicationStatusEnum}
   * @memberof ApplicationUpdate
   */
  status: ApplicationStatusEnum;
  /**
   *
   * @type {LanguagesEnum}
   * @memberof ApplicationUpdate
   */
  language?: LanguagesEnum;
  /**
   *
   * @type {boolean}
   * @memberof ApplicationUpdate
   */
  acceptedTerms?: boolean;
  /**
   *
   * @type {ApplicationSubmissionTypeEnum}
   * @memberof ApplicationUpdate
   */
  submissionType: ApplicationSubmissionTypeEnum;
  /**
   *
   * @type {string}
   * @memberof ApplicationUpdate
   */
  submissionDate?: string;
  /**
   *
   * @type {string}
   * @memberof ApplicationUpdate
   */
  receivedBy?: string;
  /**
   *
   * @type {string}
   * @memberof ApplicationUpdate
   */
  receivedAt?: string;
  /**
   *
   * @type {ApplicationReviewStatusEnum}
   * @memberof ApplicationUpdate
   */
  reviewStatus?: ApplicationReviewStatusEnum;
  /**
   *
   * @type {Array<ApplicationMultiselectQuestion>}
   * @memberof ApplicationUpdate
   */
  preferences?: Array<ApplicationMultiselectQuestion>;
  /**
   *
   * @type {Array<ApplicationMultiselectQuestion>}
   * @memberof ApplicationUpdate
   */
  programs?: Array<ApplicationMultiselectQuestion>;
  /**
   *
   * @type {IdDTO}
   * @memberof ApplicationUpdate
   */
  listings: IdDTO;
  /**
   *
   * @type {ApplicantUpdate}
   * @memberof ApplicationUpdate
   */
  applicant: ApplicantUpdate;
  /**
   *
   * @type {AddressCreate}
   * @memberof ApplicationUpdate
   */
  applicationsMailingAddress: AddressCreate;
  /**
   *
   * @type {AddressCreate}
   * @memberof ApplicationUpdate
   */
  applicationsAlternateAddress: AddressCreate;
  /**
   *
   * @type {AlternateContactUpdate}
   * @memberof ApplicationUpdate
   */
  alternateContact: AlternateContactUpdate;
  /**
   *
   * @type {AccessibilityUpdate}
   * @memberof ApplicationUpdate
   */
  accessibility: AccessibilityUpdate;
  /**
   *
   * @type {DemographicUpdate}
   * @memberof ApplicationUpdate
   */
  demographics: DemographicUpdate;
  /**
   *
   * @type {Array<HouseholdMemberUpdate>}
   * @memberof ApplicationUpdate
   */
  householdMember: Array<HouseholdMemberUpdate>;
  /**
   *
   * @type {Array<IdDTO>}
   * @memberof ApplicationUpdate
   */
  preferredUnitTypes: Array<IdDTO>;
}

/**
 *
 * @export
 * @enum {string}
 */

export const ApplicationsFilterEnum = {
  All: "all",
  Lottery: "lottery",
  Closed: "closed",
  Open: "open",
} as const;

export type ApplicationsFilterEnum =
  (typeof ApplicationsFilterEnum)[keyof typeof ApplicationsFilterEnum];

/**
 *
 * @export
 * @interface Asset
 */
export interface Asset {
  /**
   *
   * @type {string}
   * @memberof Asset
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof Asset
   */
  createdAt: string;
  /**
   *
   * @type {string}
   * @memberof Asset
   */
  updatedAt: string;
  /**
   *
   * @type {string}
   * @memberof Asset
   */
  fileId: string;
  /**
   *
   * @type {string}
   * @memberof Asset
   */
  label: string;
}
/**
 *
 * @export
 * @interface AssetCreate
 */
export interface AssetCreate {
  /**
   *
   * @type {string}
   * @memberof AssetCreate
   */
  fileId: string;
  /**
   *
   * @type {string}
   * @memberof AssetCreate
   */
  label: string;
  /**
   *
   * @type {string}
   * @memberof AssetCreate
   */
  id?: string;
}
/**
 *
 * @export
 * @interface BooleanInput
 */
export interface BooleanInput {
  /**
   *
   * @type {InputType}
   * @memberof BooleanInput
   */
  type: InputType;
  /**
   *
   * @type {string}
   * @memberof BooleanInput
   */
  key: string;
  /**
   *
   * @type {boolean}
   * @memberof BooleanInput
   */
  value: boolean;
}

/**
 *
 * @export
 * @interface Confirm
 */
export interface Confirm {
  /**
   *
   * @type {string}
   * @memberof Confirm
   */
  token: string;
  /**
   *
   * @type {string}
   * @memberof Confirm
   */
  password?: string;
}
/**
 *
 * @export
 * @interface ConfirmationRequest
 */
export interface ConfirmationRequest {
  /**
   *
   * @type {string}
   * @memberof ConfirmationRequest
   */
  token: string;
}
/**
 *
 * @export
 * @interface CreatePresignedUploadMetadata
 */
export interface CreatePresignedUploadMetadata {
  /**
   *
   * @type {object}
   * @memberof CreatePresignedUploadMetadata
   */
  parametersToSign: object;
}
/**
 *
 * @export
 * @interface DataTransferDTO
 */
export interface DataTransferDTO {
  /**
   *
   * @type {string}
   * @memberof DataTransferDTO
   */
  connectionString: string;
  /**
   *
   * @type {string}
   * @memberof DataTransferDTO
   */
  jurisdiction: string;
}
/**
 *
 * @export
 * @interface Demographic
 */
export interface Demographic {
  /**
   *
   * @type {string}
   * @memberof Demographic
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof Demographic
   */
  createdAt: string;
  /**
   *
   * @type {string}
   * @memberof Demographic
   */
  updatedAt: string;
  /**
   *
   * @type {string}
   * @memberof Demographic
   */
  ethnicity?: string;
  /**
   *
   * @type {string}
   * @memberof Demographic
   */
  gender?: string;
  /**
   *
   * @type {string}
   * @memberof Demographic
   */
  sexualOrientation?: string;
  /**
   *
   * @type {Array<string>}
   * @memberof Demographic
   */
  howDidYouHear?: Array<string>;
  /**
   *
   * @type {Array<string>}
   * @memberof Demographic
   */
  race?: Array<string>;
  /**
   *
   * @type {string}
   * @memberof Demographic
   */
  spokenLanguage?: string;
}
/**
 *
 * @export
 * @interface DemographicUpdate
 */
export interface DemographicUpdate {
  /**
   *
   * @type {string}
   * @memberof DemographicUpdate
   */
  ethnicity?: string;
  /**
   *
   * @type {string}
   * @memberof DemographicUpdate
   */
  gender?: string;
  /**
   *
   * @type {string}
   * @memberof DemographicUpdate
   */
  sexualOrientation?: string;
  /**
   *
   * @type {Array<string>}
   * @memberof DemographicUpdate
   */
  howDidYouHear?: Array<string>;
  /**
   *
   * @type {Array<string>}
   * @memberof DemographicUpdate
   */
  race?: Array<string>;
  /**
   *
   * @type {string}
   * @memberof DemographicUpdate
   */
  spokenLanguage?: string;
}
/**
 *
 * @export
 * @interface EmailAndAppUrl
 */
export interface EmailAndAppUrl {
  /**
   *
   * @type {string}
   * @memberof EmailAndAppUrl
   */
  email: string;
  /**
   *
   * @type {string}
   * @memberof EmailAndAppUrl
   */
  appUrl?: string;
}
/**
 *
 * @export
 * @enum {string}
 */

export const FilterAvailabilityEnum = {
  WaitlistOpen: "waitlistOpen",
  UnitsAvailable: "unitsAvailable",
} as const;

export type FilterAvailabilityEnum =
  (typeof FilterAvailabilityEnum)[keyof typeof FilterAvailabilityEnum];

/**
 *
 * @export
 * @enum {string}
 */

export const FlaggedSetStatusEnum = {
  Flagged: "flagged",
  Pending: "pending",
  Resolved: "resolved",
} as const;

export type FlaggedSetStatusEnum =
  (typeof FlaggedSetStatusEnum)[keyof typeof FlaggedSetStatusEnum];

/**
 *
 * @export
 * @interface HMI
 */
export interface HMI {
  /**
   *
   * @type {object}
   * @memberof HMI
   */
  columns: object;
  /**
   *
   * @type {Array<object>}
   * @memberof HMI
   */
  rows: Array<object>;
}
/**
 *
 * @export
 * @interface HouseholdMember
 */
export interface HouseholdMember {
  /**
   *
   * @type {string}
   * @memberof HouseholdMember
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof HouseholdMember
   */
  createdAt: string;
  /**
   *
   * @type {string}
   * @memberof HouseholdMember
   */
  updatedAt: string;
  /**
   *
   * @type {number}
   * @memberof HouseholdMember
   */
  orderId?: number;
  /**
   *
   * @type {string}
   * @memberof HouseholdMember
   */
  firstName?: string;
  /**
   *
   * @type {string}
   * @memberof HouseholdMember
   */
  middleName?: string;
  /**
   *
   * @type {string}
   * @memberof HouseholdMember
   */
  lastName?: string;
  /**
   *
   * @type {string}
   * @memberof HouseholdMember
   */
  birthMonth?: string;
  /**
   *
   * @type {string}
   * @memberof HouseholdMember
   */
  birthDay?: string;
  /**
   *
   * @type {string}
   * @memberof HouseholdMember
   */
  birthYear?: string;
  /**
   *
   * @type {YesNoEnum}
   * @memberof HouseholdMember
   */
  sameAddress?: YesNoEnum;
  /**
   *
   * @type {HouseholdMemberRelationship}
   * @memberof HouseholdMember
   */
  relationship?: HouseholdMemberRelationship;
  /**
   *
   * @type {YesNoEnum}
   * @memberof HouseholdMember
   */
  workInRegion?: YesNoEnum;
  /**
   *
   * @type {Address}
   * @memberof HouseholdMember
   */
  householdMemberWorkAddress?: Address;
  /**
   *
   * @type {Address}
   * @memberof HouseholdMember
   */
  householdMemberAddress: Address;
}

/**
 *
 * @export
 * @enum {string}
 */

export const HouseholdMemberRelationship = {
  Spouse: "spouse",
  RegisteredDomesticPartner: "registeredDomesticPartner",
  Parent: "parent",
  Child: "child",
  Sibling: "sibling",
  Cousin: "cousin",
  Aunt: "aunt",
  Uncle: "uncle",
  Nephew: "nephew",
  Niece: "niece",
  Grandparent: "grandparent",
  GreatGrandparent: "greatGrandparent",
  InLaw: "inLaw",
  Friend: "friend",
  Other: "other",
} as const;

export type HouseholdMemberRelationship =
  (typeof HouseholdMemberRelationship)[keyof typeof HouseholdMemberRelationship];

/**
 *
 * @export
 * @interface HouseholdMemberUpdate
 */
export interface HouseholdMemberUpdate {
  /**
   *
   * @type {number}
   * @memberof HouseholdMemberUpdate
   */
  orderId?: number;
  /**
   *
   * @type {string}
   * @memberof HouseholdMemberUpdate
   */
  firstName?: string;
  /**
   *
   * @type {string}
   * @memberof HouseholdMemberUpdate
   */
  middleName?: string;
  /**
   *
   * @type {string}
   * @memberof HouseholdMemberUpdate
   */
  lastName?: string;
  /**
   *
   * @type {string}
   * @memberof HouseholdMemberUpdate
   */
  birthMonth?: string;
  /**
   *
   * @type {string}
   * @memberof HouseholdMemberUpdate
   */
  birthDay?: string;
  /**
   *
   * @type {string}
   * @memberof HouseholdMemberUpdate
   */
  birthYear?: string;
  /**
   *
   * @type {YesNoEnum}
   * @memberof HouseholdMemberUpdate
   */
  sameAddress?: YesNoEnum;
  /**
   *
   * @type {HouseholdMemberRelationship}
   * @memberof HouseholdMemberUpdate
   */
  relationship?: HouseholdMemberRelationship;
  /**
   *
   * @type {YesNoEnum}
   * @memberof HouseholdMemberUpdate
   */
  workInRegion?: YesNoEnum;
  /**
   *
   * @type {string}
   * @memberof HouseholdMemberUpdate
   */
  id?: string;
  /**
   *
   * @type {AddressCreate}
   * @memberof HouseholdMemberUpdate
   */
  householdMemberAddress: AddressCreate;
  /**
   *
   * @type {AddressCreate}
   * @memberof HouseholdMemberUpdate
   */
  householdMemberWorkAddress?: AddressCreate;
}

/**
 *
 * @export
 * @interface IdDTO
 */
export interface IdDTO {
  /**
   *
   * @type {string}
   * @memberof IdDTO
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof IdDTO
   */
  name?: string;
  /**
   *
   * @type {number}
   * @memberof IdDTO
   */
  ordinal?: number;
}
/**
 *
 * @export
 * @enum {string}
 */

export const IncomePeriodEnum = {
  PerMonth: "perMonth",
  PerYear: "perYear",
} as const;

export type IncomePeriodEnum =
  (typeof IncomePeriodEnum)[keyof typeof IncomePeriodEnum];

/**
 *
 * @export
 * @enum {string}
 */

export const InputType = {
  Boolean: "boolean",
  Text: "text",
  Address: "address",
  HhMemberSelect: "hhMemberSelect",
} as const;

export type InputType = (typeof InputType)[keyof typeof InputType];

/**
 *
 * @export
 * @interface Jurisdiction
 */
export interface Jurisdiction {
  /**
   *
   * @type {string}
   * @memberof Jurisdiction
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof Jurisdiction
   */
  createdAt: string;
  /**
   *
   * @type {string}
   * @memberof Jurisdiction
   */
  updatedAt: string;
  /**
   *
   * @type {string}
   * @memberof Jurisdiction
   */
  name: string;
  /**
   *
   * @type {string}
   * @memberof Jurisdiction
   */
  notificationsSignUpUrl?: string;
  /**
   *
   * @type {Array<LanguagesEnum>}
   * @memberof Jurisdiction
   */
  languages: Array<LanguagesEnum>;
  /**
   *
   * @type {Array<IdDTO>}
   * @memberof Jurisdiction
   */
  multiselectQuestions: Array<IdDTO>;
  /**
   *
   * @type {string}
   * @memberof Jurisdiction
   */
  partnerTerms?: string;
  /**
   *
   * @type {string}
   * @memberof Jurisdiction
   */
  publicUrl: string;
  /**
   *
   * @type {string}
   * @memberof Jurisdiction
   */
  emailFromAddress: string;
  /**
   *
   * @type {string}
   * @memberof Jurisdiction
   */
  rentalAssistanceDefault: string;
  /**
   *
   * @type {boolean}
   * @memberof Jurisdiction
   */
  enablePartnerSettings?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof Jurisdiction
   */
  enablePartnerDemographics?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof Jurisdiction
   */
  enableListingOpportunity?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof Jurisdiction
   */
  enableGeocodingPreferences?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof Jurisdiction
   */
  enableGeocodingRadiusMethod?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof Jurisdiction
   */
  enableAccessibilityFeatures: boolean;
  /**
   *
   * @type {boolean}
   * @memberof Jurisdiction
   */
  enableUtilitiesIncluded: boolean;
  /**
   *
   * @type {boolean}
   * @memberof Jurisdiction
   */
  allowSingleUseCodeLogin: boolean;
  /**
   *
   * @type {Array<string>}
   * @memberof Jurisdiction
   */
  listingApprovalPermissions: Array<JurisdictionListingApprovalPermissionsEnum>;
}

export const JurisdictionListingApprovalPermissionsEnum = {
  User: "user",
  Partner: "partner",
  Admin: "admin",
  JurisdictionAdmin: "jurisdictionAdmin",
} as const;

export type JurisdictionListingApprovalPermissionsEnum =
  (typeof JurisdictionListingApprovalPermissionsEnum)[keyof typeof JurisdictionListingApprovalPermissionsEnum];

/**
 *
 * @export
 * @interface JurisdictionCreate
 */
export interface JurisdictionCreate {
  /**
   *
   * @type {string}
   * @memberof JurisdictionCreate
   */
  name: string;
  /**
   *
   * @type {string}
   * @memberof JurisdictionCreate
   */
  notificationsSignUpUrl?: string;
  /**
   *
   * @type {Array<LanguagesEnum>}
   * @memberof JurisdictionCreate
   */
  languages: Array<LanguagesEnum>;
  /**
   *
   * @type {string}
   * @memberof JurisdictionCreate
   */
  partnerTerms?: string;
  /**
   *
   * @type {string}
   * @memberof JurisdictionCreate
   */
  publicUrl: string;
  /**
   *
   * @type {string}
   * @memberof JurisdictionCreate
   */
  emailFromAddress: string;
  /**
   *
   * @type {string}
   * @memberof JurisdictionCreate
   */
  rentalAssistanceDefault: string;
  /**
   *
   * @type {boolean}
   * @memberof JurisdictionCreate
   */
  enablePartnerSettings?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof JurisdictionCreate
   */
  enablePartnerDemographics?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof JurisdictionCreate
   */
  enableListingOpportunity?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof JurisdictionCreate
   */
  enableGeocodingPreferences?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof JurisdictionCreate
   */
  enableGeocodingRadiusMethod?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof JurisdictionCreate
   */
  enableAccessibilityFeatures: boolean;
  /**
   *
   * @type {boolean}
   * @memberof JurisdictionCreate
   */
  enableUtilitiesIncluded: boolean;
  /**
   *
   * @type {boolean}
   * @memberof JurisdictionCreate
   */
  allowSingleUseCodeLogin: boolean;
  /**
   *
   * @type {Array<string>}
   * @memberof JurisdictionCreate
   */
  listingApprovalPermissions: Array<JurisdictionCreateListingApprovalPermissionsEnum>;
}

export const JurisdictionCreateListingApprovalPermissionsEnum = {
  User: "user",
  Partner: "partner",
  Admin: "admin",
  JurisdictionAdmin: "jurisdictionAdmin",
} as const;

export type JurisdictionCreateListingApprovalPermissionsEnum =
  (typeof JurisdictionCreateListingApprovalPermissionsEnum)[keyof typeof JurisdictionCreateListingApprovalPermissionsEnum];

/**
 *
 * @export
 * @interface JurisdictionUpdate
 */
export interface JurisdictionUpdate {
  /**
   *
   * @type {string}
   * @memberof JurisdictionUpdate
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof JurisdictionUpdate
   */
  name: string;
  /**
   *
   * @type {string}
   * @memberof JurisdictionUpdate
   */
  notificationsSignUpUrl?: string;
  /**
   *
   * @type {Array<LanguagesEnum>}
   * @memberof JurisdictionUpdate
   */
  languages: Array<LanguagesEnum>;
  /**
   *
   * @type {string}
   * @memberof JurisdictionUpdate
   */
  partnerTerms?: string;
  /**
   *
   * @type {string}
   * @memberof JurisdictionUpdate
   */
  publicUrl: string;
  /**
   *
   * @type {string}
   * @memberof JurisdictionUpdate
   */
  emailFromAddress: string;
  /**
   *
   * @type {string}
   * @memberof JurisdictionUpdate
   */
  rentalAssistanceDefault: string;
  /**
   *
   * @type {boolean}
   * @memberof JurisdictionUpdate
   */
  enablePartnerSettings?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof JurisdictionUpdate
   */
  enablePartnerDemographics?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof JurisdictionUpdate
   */
  enableListingOpportunity?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof JurisdictionUpdate
   */
  enableGeocodingPreferences?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof JurisdictionUpdate
   */
  enableGeocodingRadiusMethod?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof JurisdictionUpdate
   */
  enableAccessibilityFeatures: boolean;
  /**
   *
   * @type {boolean}
   * @memberof JurisdictionUpdate
   */
  enableUtilitiesIncluded: boolean;
  /**
   *
   * @type {boolean}
   * @memberof JurisdictionUpdate
   */
  allowSingleUseCodeLogin: boolean;
  /**
   *
   * @type {Array<string>}
   * @memberof JurisdictionUpdate
   */
  listingApprovalPermissions: Array<JurisdictionUpdateListingApprovalPermissionsEnum>;
}

export const JurisdictionUpdateListingApprovalPermissionsEnum = {
  User: "user",
  Partner: "partner",
  Admin: "admin",
  JurisdictionAdmin: "jurisdictionAdmin",
} as const;

export type JurisdictionUpdateListingApprovalPermissionsEnum =
  (typeof JurisdictionUpdateListingApprovalPermissionsEnum)[keyof typeof JurisdictionUpdateListingApprovalPermissionsEnum];

/**
 *
 * @export
 * @enum {string}
 */

export const LanguagesEnum = {
  En: "en",
  Es: "es",
  Vi: "vi",
  Zh: "zh",
  Tl: "tl",
} as const;

export type LanguagesEnum = (typeof LanguagesEnum)[keyof typeof LanguagesEnum];

/**
 *
 * @export
 * @interface Listing
 */
export interface Listing {
  /**
   *
   * @type {string}
   * @memberof Listing
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof Listing
   */
  createdAt: string;
  /**
   *
   * @type {string}
   * @memberof Listing
   */
  updatedAt: string;
  /**
   *
   * @type {string}
   * @memberof Listing
   */
  additionalApplicationSubmissionNotes?: string;
  /**
   *
   * @type {boolean}
   * @memberof Listing
   */
  digitalApplication?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof Listing
   */
  commonDigitalApplication?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof Listing
   */
  paperApplication?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof Listing
   */
  referralOpportunity?: boolean;
  /**
   *
   * @type {string}
   * @memberof Listing
   */
  accessibility?: string;
  /**
   *
   * @type {string}
   * @memberof Listing
   */
  amenities?: string;
  /**
   *
   * @type {number}
   * @memberof Listing
   */
  buildingTotalUnits?: number;
  /**
   *
   * @type {string}
   * @memberof Listing
   */
  developer?: string;
  /**
   *
   * @type {number}
   * @memberof Listing
   */
  householdSizeMax?: number;
  /**
   *
   * @type {number}
   * @memberof Listing
   */
  householdSizeMin?: number;
  /**
   *
   * @type {string}
   * @memberof Listing
   */
  neighborhood?: string;
  /**
   *
   * @type {string}
   * @memberof Listing
   */
  petPolicy?: string;
  /**
   *
   * @type {string}
   * @memberof Listing
   */
  smokingPolicy?: string;
  /**
   *
   * @type {number}
   * @memberof Listing
   */
  unitsAvailable?: number;
  /**
   *
   * @type {string}
   * @memberof Listing
   */
  unitAmenities?: string;
  /**
   *
   * @type {string}
   * @memberof Listing
   */
  servicesOffered?: string;
  /**
   *
   * @type {number}
   * @memberof Listing
   */
  yearBuilt?: number;
  /**
   *
   * @type {string}
   * @memberof Listing
   */
  applicationDueDate?: string;
  /**
   *
   * @type {string}
   * @memberof Listing
   */
  applicationOpenDate?: string;
  /**
   *
   * @type {string}
   * @memberof Listing
   */
  applicationFee?: string;
  /**
   *
   * @type {string}
   * @memberof Listing
   */
  applicationOrganization?: string;
  /**
   *
   * @type {string}
   * @memberof Listing
   */
  applicationPickUpAddressOfficeHours?: string;
  /**
   *
   * @type {ApplicationAddressTypeEnum}
   * @memberof Listing
   */
  applicationPickUpAddressType?: ApplicationAddressTypeEnum;
  /**
   *
   * @type {string}
   * @memberof Listing
   */
  applicationDropOffAddressOfficeHours?: string;
  /**
   *
   * @type {ApplicationAddressTypeEnum}
   * @memberof Listing
   */
  applicationDropOffAddressType?: ApplicationAddressTypeEnum;
  /**
   *
   * @type {ApplicationAddressTypeEnum}
   * @memberof Listing
   */
  applicationMailingAddressType?: ApplicationAddressTypeEnum;
  /**
   *
   * @type {string}
   * @memberof Listing
   */
  buildingSelectionCriteria?: string;
  /**
   *
   * @type {string}
   * @memberof Listing
   */
  costsNotIncluded?: string;
  /**
   *
   * @type {string}
   * @memberof Listing
   */
  creditHistory?: string;
  /**
   *
   * @type {string}
   * @memberof Listing
   */
  criminalBackground?: string;
  /**
   *
   * @type {string}
   * @memberof Listing
   */
  depositMin?: string;
  /**
   *
   * @type {string}
   * @memberof Listing
   */
  depositMax?: string;
  /**
   *
   * @type {string}
   * @memberof Listing
   */
  depositHelperText?: string;
  /**
   *
   * @type {boolean}
   * @memberof Listing
   */
  disableUnitsAccordion?: boolean;
  /**
   *
   * @type {string}
   * @memberof Listing
   */
  leasingAgentEmail?: string;
  /**
   *
   * @type {string}
   * @memberof Listing
   */
  leasingAgentName?: string;
  /**
   *
   * @type {string}
   * @memberof Listing
   */
  leasingAgentOfficeHours?: string;
  /**
   *
   * @type {string}
   * @memberof Listing
   */
  leasingAgentPhone?: string;
  /**
   *
   * @type {string}
   * @memberof Listing
   */
  leasingAgentTitle?: string;
  /**
   *
   * @type {string}
   * @memberof Listing
   */
  name: string;
  /**
   *
   * @type {string}
   * @memberof Listing
   */
  postmarkedApplicationsReceivedByDate?: string;
  /**
   *
   * @type {string}
   * @memberof Listing
   */
  programRules?: string;
  /**
   *
   * @type {string}
   * @memberof Listing
   */
  rentalAssistance?: string;
  /**
   *
   * @type {string}
   * @memberof Listing
   */
  rentalHistory?: string;
  /**
   *
   * @type {string}
   * @memberof Listing
   */
  requiredDocuments?: string;
  /**
   *
   * @type {string}
   * @memberof Listing
   */
  specialNotes?: string;
  /**
   *
   * @type {number}
   * @memberof Listing
   */
  waitlistCurrentSize?: number;
  /**
   *
   * @type {number}
   * @memberof Listing
   */
  waitlistMaxSize?: number;
  /**
   *
   * @type {string}
   * @memberof Listing
   */
  whatToExpect?: string;
  /**
   *
   * @type {ListingsStatusEnum}
   * @memberof Listing
   */
  status: ListingsStatusEnum;
  /**
   *
   * @type {ReviewOrderTypeEnum}
   * @memberof Listing
   */
  reviewOrderType?: ReviewOrderTypeEnum;
  /**
   *
   * @type {object}
   * @memberof Listing
   */
  applicationConfig?: object;
  /**
   *
   * @type {boolean}
   * @memberof Listing
   */
  displayWaitlistSize: boolean;
  /**
   *
   * @type {boolean}
   * @memberof Listing
   */
  showWaitlist?: boolean;
  /**
   *
   * @type {string}
   * @memberof Listing
   */
  reservedCommunityDescription?: string;
  /**
   *
   * @type {number}
   * @memberof Listing
   */
  reservedCommunityMinAge?: number;
  /**
   *
   * @type {string}
   * @memberof Listing
   */
  resultLink?: string;
  /**
   *
   * @type {boolean}
   * @memberof Listing
   */
  isWaitlistOpen?: boolean;
  /**
   *
   * @type {number}
   * @memberof Listing
   */
  waitlistOpenSpots?: number;
  /**
   *
   * @type {boolean}
   * @memberof Listing
   */
  customMapPin?: boolean;
  /**
   *
   * @type {string}
   * @memberof Listing
   */
  contentUpdatedAt?: string;
  /**
   *
   * @type {string}
   * @memberof Listing
   */
  publishedAt?: string;
  /**
   *
   * @type {string}
   * @memberof Listing
   */
  closedAt?: string;
  /**
   *
   * @type {string}
   * @memberof Listing
   */
  afsLastRunAt?: string;
  /**
   *
   * @type {string}
   * @memberof Listing
   */
  lotteryLastPublishedAt?: string;
  /**
   *
   * @type {string}
   * @memberof Listing
   */
  lotteryLastRunAt?: string;
  /**
   *
   * @type {LotteryStatusEnum}
   * @memberof Listing
   */
  lotteryStatus?: LotteryStatusEnum;
  /**
   *
   * @type {string}
   * @memberof Listing
   */
  lastApplicationUpdateAt?: string;
  /**
   *
   * @type {Array<ListingMultiselectQuestion>}
   * @memberof Listing
   */
  listingMultiselectQuestions?: Array<ListingMultiselectQuestion>;
  /**
   *
   * @type {Array<ApplicationMethod>}
   * @memberof Listing
   */
  applicationMethods: Array<ApplicationMethod>;
  /**
   *
   * @type {ApplicationMethod}
   * @memberof Listing
   */
  referralApplication?: ApplicationMethod;
  /**
   *
   * @type {Array<Asset>}
   * @memberof Listing
   */
  assets: Array<Asset>;
  /**
   *
   * @type {Array<ListingEvent>}
   * @memberof Listing
   */
  listingEvents: Array<ListingEvent>;
  /**
   *
   * @type {Address}
   * @memberof Listing
   */
  listingsBuildingAddress: Address;
  /**
   *
   * @type {Address}
   * @memberof Listing
   */
  listingsApplicationPickUpAddress?: Address;
  /**
   *
   * @type {Address}
   * @memberof Listing
   */
  listingsApplicationDropOffAddress?: Address;
  /**
   *
   * @type {Address}
   * @memberof Listing
   */
  listingsApplicationMailingAddress?: Address;
  /**
   *
   * @type {Address}
   * @memberof Listing
   */
  listingsLeasingAgentAddress?: Address;
  /**
   *
   * @type {Asset}
   * @memberof Listing
   */
  listingsBuildingSelectionCriteriaFile?: Asset;
  /**
   *
   * @type {IdDTO}
   * @memberof Listing
   */
  jurisdictions: IdDTO;
  /**
   *
   * @type {Asset}
   * @memberof Listing
   */
  listingsResult?: Asset;
  /**
   *
   * @type {IdDTO}
   * @memberof Listing
   */
  reservedCommunityTypes?: IdDTO;
  /**
   *
   * @type {Array<ListingImage>}
   * @memberof Listing
   */
  listingImages?: Array<ListingImage>;
  /**
   *
   * @type {ListingFeatures}
   * @memberof Listing
   */
  listingFeatures?: ListingFeatures;
  /**
   *
   * @type {ListingUtilities}
   * @memberof Listing
   */
  listingUtilities?: ListingUtilities;
  /**
   *
   * @type {Array<Unit>}
   * @memberof Listing
   */
  units: Array<Unit>;
  /**
   *
   * @type {UnitsSummarized}
   * @memberof Listing
   */
  unitsSummarized?: UnitsSummarized;
  /**
   *
   * @type {Array<UnitsSummary>}
   * @memberof Listing
   */
  unitsSummary?: Array<UnitsSummary>;
  /**
   *
   * @type {string}
   * @memberof Listing
   */
  urlSlug?: string;
  /**
   *
   * @type {string}
   * @memberof Listing
   */
  requestedChanges?: string;
  /**
   *
   * @type {string}
   * @memberof Listing
   */
  requestedChangesDate?: string;
  /**
   *
   * @type {IdDTO}
   * @memberof Listing
   */
  requestedChangesUser?: IdDTO;
  /**
   *
   * @type {boolean}
   * @memberof Listing
   */
  isExternal?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof Listing
   */
  lotteryOptIn?: boolean;
  /**
   *
   * @type {Array<ApplicationLotteryTotal>}
   * @memberof Listing
   */
  applicationLotteryTotals: Array<ApplicationLotteryTotal>;
}

/**
 *
 * @export
 * @interface ListingCreate
 */
export interface ListingCreate {
  /**
   *
   * @type {string}
   * @memberof ListingCreate
   */
  additionalApplicationSubmissionNotes?: string;
  /**
   *
   * @type {boolean}
   * @memberof ListingCreate
   */
  digitalApplication?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof ListingCreate
   */
  commonDigitalApplication?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof ListingCreate
   */
  paperApplication?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof ListingCreate
   */
  referralOpportunity?: boolean;
  /**
   *
   * @type {string}
   * @memberof ListingCreate
   */
  accessibility?: string;
  /**
   *
   * @type {string}
   * @memberof ListingCreate
   */
  amenities?: string;
  /**
   *
   * @type {number}
   * @memberof ListingCreate
   */
  buildingTotalUnits?: number;
  /**
   *
   * @type {string}
   * @memberof ListingCreate
   */
  developer?: string;
  /**
   *
   * @type {number}
   * @memberof ListingCreate
   */
  householdSizeMax?: number;
  /**
   *
   * @type {number}
   * @memberof ListingCreate
   */
  householdSizeMin?: number;
  /**
   *
   * @type {string}
   * @memberof ListingCreate
   */
  neighborhood?: string;
  /**
   *
   * @type {string}
   * @memberof ListingCreate
   */
  petPolicy?: string;
  /**
   *
   * @type {string}
   * @memberof ListingCreate
   */
  smokingPolicy?: string;
  /**
   *
   * @type {number}
   * @memberof ListingCreate
   */
  unitsAvailable?: number;
  /**
   *
   * @type {string}
   * @memberof ListingCreate
   */
  unitAmenities?: string;
  /**
   *
   * @type {string}
   * @memberof ListingCreate
   */
  servicesOffered?: string;
  /**
   *
   * @type {number}
   * @memberof ListingCreate
   */
  yearBuilt?: number;
  /**
   *
   * @type {string}
   * @memberof ListingCreate
   */
  applicationDueDate?: string;
  /**
   *
   * @type {string}
   * @memberof ListingCreate
   */
  applicationOpenDate?: string;
  /**
   *
   * @type {string}
   * @memberof ListingCreate
   */
  applicationFee?: string;
  /**
   *
   * @type {string}
   * @memberof ListingCreate
   */
  applicationOrganization?: string;
  /**
   *
   * @type {string}
   * @memberof ListingCreate
   */
  applicationPickUpAddressOfficeHours?: string;
  /**
   *
   * @type {ApplicationAddressTypeEnum}
   * @memberof ListingCreate
   */
  applicationPickUpAddressType?: ApplicationAddressTypeEnum;
  /**
   *
   * @type {string}
   * @memberof ListingCreate
   */
  applicationDropOffAddressOfficeHours?: string;
  /**
   *
   * @type {ApplicationAddressTypeEnum}
   * @memberof ListingCreate
   */
  applicationDropOffAddressType?: ApplicationAddressTypeEnum;
  /**
   *
   * @type {ApplicationAddressTypeEnum}
   * @memberof ListingCreate
   */
  applicationMailingAddressType?: ApplicationAddressTypeEnum;
  /**
   *
   * @type {string}
   * @memberof ListingCreate
   */
  buildingSelectionCriteria?: string;
  /**
   *
   * @type {string}
   * @memberof ListingCreate
   */
  costsNotIncluded?: string;
  /**
   *
   * @type {string}
   * @memberof ListingCreate
   */
  creditHistory?: string;
  /**
   *
   * @type {string}
   * @memberof ListingCreate
   */
  criminalBackground?: string;
  /**
   *
   * @type {string}
   * @memberof ListingCreate
   */
  depositMin?: string;
  /**
   *
   * @type {string}
   * @memberof ListingCreate
   */
  depositMax?: string;
  /**
   *
   * @type {string}
   * @memberof ListingCreate
   */
  depositHelperText?: string;
  /**
   *
   * @type {boolean}
   * @memberof ListingCreate
   */
  disableUnitsAccordion?: boolean;
  /**
   *
   * @type {string}
   * @memberof ListingCreate
   */
  leasingAgentEmail?: string;
  /**
   *
   * @type {string}
   * @memberof ListingCreate
   */
  leasingAgentName?: string;
  /**
   *
   * @type {string}
   * @memberof ListingCreate
   */
  leasingAgentOfficeHours?: string;
  /**
   *
   * @type {string}
   * @memberof ListingCreate
   */
  leasingAgentPhone?: string;
  /**
   *
   * @type {string}
   * @memberof ListingCreate
   */
  leasingAgentTitle?: string;
  /**
   *
   * @type {string}
   * @memberof ListingCreate
   */
  name: string;
  /**
   *
   * @type {string}
   * @memberof ListingCreate
   */
  postmarkedApplicationsReceivedByDate?: string;
  /**
   *
   * @type {string}
   * @memberof ListingCreate
   */
  programRules?: string;
  /**
   *
   * @type {string}
   * @memberof ListingCreate
   */
  rentalAssistance?: string;
  /**
   *
   * @type {string}
   * @memberof ListingCreate
   */
  rentalHistory?: string;
  /**
   *
   * @type {string}
   * @memberof ListingCreate
   */
  requiredDocuments?: string;
  /**
   *
   * @type {string}
   * @memberof ListingCreate
   */
  specialNotes?: string;
  /**
   *
   * @type {number}
   * @memberof ListingCreate
   */
  waitlistCurrentSize?: number;
  /**
   *
   * @type {number}
   * @memberof ListingCreate
   */
  waitlistMaxSize?: number;
  /**
   *
   * @type {string}
   * @memberof ListingCreate
   */
  whatToExpect?: string;
  /**
   *
   * @type {ListingsStatusEnum}
   * @memberof ListingCreate
   */
  status: ListingsStatusEnum;
  /**
   *
   * @type {ReviewOrderTypeEnum}
   * @memberof ListingCreate
   */
  reviewOrderType?: ReviewOrderTypeEnum;
  /**
   *
   * @type {boolean}
   * @memberof ListingCreate
   */
  displayWaitlistSize: boolean;
  /**
   *
   * @type {string}
   * @memberof ListingCreate
   */
  reservedCommunityDescription?: string;
  /**
   *
   * @type {number}
   * @memberof ListingCreate
   */
  reservedCommunityMinAge?: number;
  /**
   *
   * @type {string}
   * @memberof ListingCreate
   */
  resultLink?: string;
  /**
   *
   * @type {boolean}
   * @memberof ListingCreate
   */
  isWaitlistOpen?: boolean;
  /**
   *
   * @type {number}
   * @memberof ListingCreate
   */
  waitlistOpenSpots?: number;
  /**
   *
   * @type {boolean}
   * @memberof ListingCreate
   */
  customMapPin?: boolean;
  /**
   *
   * @type {string}
   * @memberof ListingCreate
   */
  contentUpdatedAt?: string;
  /**
   *
   * @type {string}
   * @memberof ListingCreate
   */
  lotteryLastPublishedAt?: string;
  /**
   *
   * @type {string}
   * @memberof ListingCreate
   */
  lotteryLastRunAt?: string;
  /**
   *
   * @type {LotteryStatusEnum}
   * @memberof ListingCreate
   */
  lotteryStatus?: LotteryStatusEnum;
  /**
   *
   * @type {string}
   * @memberof ListingCreate
   */
  lastApplicationUpdateAt?: string;
  /**
   *
   * @type {IdDTO}
   * @memberof ListingCreate
   */
  jurisdictions: IdDTO;
  /**
   *
   * @type {IdDTO}
   * @memberof ListingCreate
   */
  reservedCommunityTypes?: IdDTO;
  /**
   *
   * @type {string}
   * @memberof ListingCreate
   */
  requestedChanges?: string;
  /**
   *
   * @type {string}
   * @memberof ListingCreate
   */
  requestedChangesDate?: string;
  /**
   *
   * @type {boolean}
   * @memberof ListingCreate
   */
  isExternal?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof ListingCreate
   */
  lotteryOptIn?: boolean;
  /**
   *
   * @type {Array<IdDTO>}
   * @memberof ListingCreate
   */
  listingMultiselectQuestions?: Array<IdDTO>;
  /**
   *
   * @type {Array<UnitCreate>}
   * @memberof ListingCreate
   */
  units?: Array<UnitCreate>;
  /**
   *
   * @type {Array<ApplicationMethodCreate>}
   * @memberof ListingCreate
   */
  applicationMethods?: Array<ApplicationMethodCreate>;
  /**
   *
   * @type {Array<AssetCreate>}
   * @memberof ListingCreate
   */
  assets?: Array<AssetCreate>;
  /**
   *
   * @type {Array<UnitsSummaryCreate>}
   * @memberof ListingCreate
   */
  unitsSummary: Array<UnitsSummaryCreate>;
  /**
   *
   * @type {Array<ListingImageCreate>}
   * @memberof ListingCreate
   */
  listingImages?: Array<ListingImageCreate>;
  /**
   *
   * @type {AddressCreate}
   * @memberof ListingCreate
   */
  listingsApplicationPickUpAddress?: AddressCreate;
  /**
   *
   * @type {AddressCreate}
   * @memberof ListingCreate
   */
  listingsApplicationMailingAddress?: AddressCreate;
  /**
   *
   * @type {AddressCreate}
   * @memberof ListingCreate
   */
  listingsApplicationDropOffAddress?: AddressCreate;
  /**
   *
   * @type {AddressCreate}
   * @memberof ListingCreate
   */
  listingsLeasingAgentAddress?: AddressCreate;
  /**
   *
   * @type {AddressCreate}
   * @memberof ListingCreate
   */
  listingsBuildingAddress?: AddressCreate;
  /**
   *
   * @type {AssetCreate}
   * @memberof ListingCreate
   */
  listingsBuildingSelectionCriteriaFile?: AssetCreate;
  /**
   *
   * @type {AssetCreate}
   * @memberof ListingCreate
   */
  listingsResult?: AssetCreate;
  /**
   *
   * @type {Array<ListingEventCreate>}
   * @memberof ListingCreate
   */
  listingEvents: Array<ListingEventCreate>;
  /**
   *
   * @type {ListingFeatures}
   * @memberof ListingCreate
   */
  listingFeatures?: ListingFeatures;
  /**
   *
   * @type {ListingUtilities}
   * @memberof ListingCreate
   */
  listingUtilities?: ListingUtilities;
  /**
   *
   * @type {IdDTO}
   * @memberof ListingCreate
   */
  requestedChangesUser?: IdDTO;
}

/**
 *
 * @export
 * @interface ListingDuplicate
 */
export interface ListingDuplicate {
  /**
   *
   * @type {string}
   * @memberof ListingDuplicate
   */
  name: string;
  /**
   *
   * @type {boolean}
   * @memberof ListingDuplicate
   */
  includeUnits: boolean;
  /**
   *
   * @type {IdDTO}
   * @memberof ListingDuplicate
   */
  storedListing: IdDTO;
}
/**
 *
 * @export
 * @interface ListingEvent
 */
export interface ListingEvent {
  /**
   *
   * @type {string}
   * @memberof ListingEvent
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof ListingEvent
   */
  createdAt: string;
  /**
   *
   * @type {string}
   * @memberof ListingEvent
   */
  updatedAt: string;
  /**
   *
   * @type {ListingEventsTypeEnum}
   * @memberof ListingEvent
   */
  type: ListingEventsTypeEnum;
  /**
   *
   * @type {string}
   * @memberof ListingEvent
   */
  startDate?: string;
  /**
   *
   * @type {string}
   * @memberof ListingEvent
   */
  startTime?: string;
  /**
   *
   * @type {string}
   * @memberof ListingEvent
   */
  endTime?: string;
  /**
   *
   * @type {string}
   * @memberof ListingEvent
   */
  url?: string;
  /**
   *
   * @type {string}
   * @memberof ListingEvent
   */
  note?: string;
  /**
   *
   * @type {string}
   * @memberof ListingEvent
   */
  label?: string;
  /**
   *
   * @type {Asset}
   * @memberof ListingEvent
   */
  assets?: Asset;
}

/**
 *
 * @export
 * @interface ListingEventCreate
 */
export interface ListingEventCreate {
  /**
   *
   * @type {ListingEventsTypeEnum}
   * @memberof ListingEventCreate
   */
  type: ListingEventsTypeEnum;
  /**
   *
   * @type {string}
   * @memberof ListingEventCreate
   */
  startDate?: string;
  /**
   *
   * @type {string}
   * @memberof ListingEventCreate
   */
  startTime?: string;
  /**
   *
   * @type {string}
   * @memberof ListingEventCreate
   */
  endTime?: string;
  /**
   *
   * @type {string}
   * @memberof ListingEventCreate
   */
  url?: string;
  /**
   *
   * @type {string}
   * @memberof ListingEventCreate
   */
  note?: string;
  /**
   *
   * @type {string}
   * @memberof ListingEventCreate
   */
  label?: string;
  /**
   *
   * @type {AssetCreate}
   * @memberof ListingEventCreate
   */
  assets?: AssetCreate;
}

/**
 *
 * @export
 * @enum {string}
 */

export const ListingEventsTypeEnum = {
  OpenHouse: "openHouse",
  PublicLottery: "publicLottery",
  LotteryResults: "lotteryResults",
} as const;

export type ListingEventsTypeEnum =
  (typeof ListingEventsTypeEnum)[keyof typeof ListingEventsTypeEnum];

/**
 *
 * @export
 * @interface ListingFeatures
 */
export interface ListingFeatures {
  /**
   *
   * @type {boolean}
   * @memberof ListingFeatures
   */
  elevator?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof ListingFeatures
   */
  wheelchairRamp?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof ListingFeatures
   */
  serviceAnimalsAllowed?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof ListingFeatures
   */
  accessibleParking?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof ListingFeatures
   */
  parkingOnSite?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof ListingFeatures
   */
  inUnitWasherDryer?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof ListingFeatures
   */
  laundryInBuilding?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof ListingFeatures
   */
  barrierFreeEntrance?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof ListingFeatures
   */
  rollInShower?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof ListingFeatures
   */
  grabBars?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof ListingFeatures
   */
  heatingInUnit?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof ListingFeatures
   */
  acInUnit?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof ListingFeatures
   */
  hearing?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof ListingFeatures
   */
  visual?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof ListingFeatures
   */
  mobility?: boolean;
}
/**
 *
 * @export
 * @interface ListingFilterParams
 */
export interface ListingFilterParams {
  /**
   *
   * @type {string}
   * @memberof ListingFilterParams
   */
  $comparison: ListingFilterParamsComparisonEnum;
  /**
   *
   * @type {string}
   * @memberof ListingFilterParams
   */
  name?: string;
  /**
   *
   * @type {ListingsStatusEnum}
   * @memberof ListingFilterParams
   */
  status?: ListingsStatusEnum;
  /**
   *
   * @type {string}
   * @memberof ListingFilterParams
   */
  neighborhood?: string;
  /**
   *
   * @type {number}
   * @memberof ListingFilterParams
   */
  bedrooms?: number;
  /**
   *
   * @type {number}
   * @memberof ListingFilterParams
   */
  bathrooms?: number;
  /**
   *
   * @type {string}
   * @memberof ListingFilterParams
   */
  zipcode?: string;
  /**
   *
   * @type {string}
   * @memberof ListingFilterParams
   */
  leasingAgents?: string;
  /**
   *
   * @type {string}
   * @memberof ListingFilterParams
   */
  jurisdiction?: string;
  /**
   *
   * @type {boolean}
   * @memberof ListingFilterParams
   */
  isExternal?: boolean;
  /**
   *
   * @type {FilterAvailabilityEnum}
   * @memberof ListingFilterParams
   */
  availability?: FilterAvailabilityEnum;
  /**
   *
   * @type {string}
   * @memberof ListingFilterParams
   */
  city?: string;
  /**
   *
   * @type {number}
   * @memberof ListingFilterParams
   */
  monthlyRent?: number;
  /**
   *
   * @type {Array<string>}
   * @memberof ListingFilterParams
   */
  counties?: Array<string>;
}

export const ListingFilterParamsComparisonEnum = {
  Equal: "=",
  NotEqual: "<>",
  In: "IN",
  GreaterThanOrEqualTo: ">=",
  LessThanOrEqualTo: "<=",
  Na: "NA",
} as const;

export type ListingFilterParamsComparisonEnum =
  (typeof ListingFilterParamsComparisonEnum)[keyof typeof ListingFilterParamsComparisonEnum];

/**
 *
 * @export
 * @interface ListingImage
 */
export interface ListingImage {
  /**
   *
   * @type {Asset}
   * @memberof ListingImage
   */
  assets: Asset;
  /**
   *
   * @type {number}
   * @memberof ListingImage
   */
  ordinal?: number;
}
/**
 *
 * @export
 * @interface ListingImageCreate
 */
export interface ListingImageCreate {
  /**
   *
   * @type {number}
   * @memberof ListingImageCreate
   */
  ordinal?: number;
  /**
   *
   * @type {AssetCreate}
   * @memberof ListingImageCreate
   */
  assets: AssetCreate;
}
/**
 *
 * @export
 * @interface ListingLotteryStatus
 */
export interface ListingLotteryStatus {
  /**
   *
   * @type {string}
   * @memberof ListingLotteryStatus
   */
  id: string;
  /**
   *
   * @type {LotteryStatusEnum}
   * @memberof ListingLotteryStatus
   */
  lotteryStatus: LotteryStatusEnum;
}

/**
 *
 * @export
 * @interface ListingMultiselectQuestion
 */
export interface ListingMultiselectQuestion {
  /**
   *
   * @type {MultiselectQuestion}
   * @memberof ListingMultiselectQuestion
   */
  multiselectQuestions: MultiselectQuestion;
  /**
   *
   * @type {number}
   * @memberof ListingMultiselectQuestion
   */
  ordinal?: number;
}
/**
 *
 * @export
 * @enum {string}
 */

export const ListingOrderByKeys = {
  MostRecentlyUpdated: "mostRecentlyUpdated",
  ApplicationDates: "applicationDates",
  MostRecentlyClosed: "mostRecentlyClosed",
  MostRecentlyPublished: "mostRecentlyPublished",
  Name: "name",
  WaitlistOpen: "waitlistOpen",
  Status: "status",
  UnitsAvailable: "unitsAvailable",
  MarketingType: "marketingType",
} as const;

export type ListingOrderByKeys =
  (typeof ListingOrderByKeys)[keyof typeof ListingOrderByKeys];

/**
 *
 * @export
 * @interface ListingUpdate
 */
export interface ListingUpdate {
  /**
   *
   * @type {string}
   * @memberof ListingUpdate
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof ListingUpdate
   */
  additionalApplicationSubmissionNotes?: string;
  /**
   *
   * @type {boolean}
   * @memberof ListingUpdate
   */
  digitalApplication?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof ListingUpdate
   */
  commonDigitalApplication?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof ListingUpdate
   */
  paperApplication?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof ListingUpdate
   */
  referralOpportunity?: boolean;
  /**
   *
   * @type {string}
   * @memberof ListingUpdate
   */
  accessibility?: string;
  /**
   *
   * @type {string}
   * @memberof ListingUpdate
   */
  amenities?: string;
  /**
   *
   * @type {number}
   * @memberof ListingUpdate
   */
  buildingTotalUnits?: number;
  /**
   *
   * @type {string}
   * @memberof ListingUpdate
   */
  developer?: string;
  /**
   *
   * @type {number}
   * @memberof ListingUpdate
   */
  householdSizeMax?: number;
  /**
   *
   * @type {number}
   * @memberof ListingUpdate
   */
  householdSizeMin?: number;
  /**
   *
   * @type {string}
   * @memberof ListingUpdate
   */
  neighborhood?: string;
  /**
   *
   * @type {string}
   * @memberof ListingUpdate
   */
  petPolicy?: string;
  /**
   *
   * @type {string}
   * @memberof ListingUpdate
   */
  smokingPolicy?: string;
  /**
   *
   * @type {number}
   * @memberof ListingUpdate
   */
  unitsAvailable?: number;
  /**
   *
   * @type {string}
   * @memberof ListingUpdate
   */
  unitAmenities?: string;
  /**
   *
   * @type {string}
   * @memberof ListingUpdate
   */
  servicesOffered?: string;
  /**
   *
   * @type {number}
   * @memberof ListingUpdate
   */
  yearBuilt?: number;
  /**
   *
   * @type {string}
   * @memberof ListingUpdate
   */
  applicationDueDate?: string;
  /**
   *
   * @type {string}
   * @memberof ListingUpdate
   */
  applicationOpenDate?: string;
  /**
   *
   * @type {string}
   * @memberof ListingUpdate
   */
  applicationFee?: string;
  /**
   *
   * @type {string}
   * @memberof ListingUpdate
   */
  applicationOrganization?: string;
  /**
   *
   * @type {string}
   * @memberof ListingUpdate
   */
  applicationPickUpAddressOfficeHours?: string;
  /**
   *
   * @type {ApplicationAddressTypeEnum}
   * @memberof ListingUpdate
   */
  applicationPickUpAddressType?: ApplicationAddressTypeEnum;
  /**
   *
   * @type {string}
   * @memberof ListingUpdate
   */
  applicationDropOffAddressOfficeHours?: string;
  /**
   *
   * @type {ApplicationAddressTypeEnum}
   * @memberof ListingUpdate
   */
  applicationDropOffAddressType?: ApplicationAddressTypeEnum;
  /**
   *
   * @type {ApplicationAddressTypeEnum}
   * @memberof ListingUpdate
   */
  applicationMailingAddressType?: ApplicationAddressTypeEnum;
  /**
   *
   * @type {string}
   * @memberof ListingUpdate
   */
  buildingSelectionCriteria?: string;
  /**
   *
   * @type {string}
   * @memberof ListingUpdate
   */
  costsNotIncluded?: string;
  /**
   *
   * @type {string}
   * @memberof ListingUpdate
   */
  creditHistory?: string;
  /**
   *
   * @type {string}
   * @memberof ListingUpdate
   */
  criminalBackground?: string;
  /**
   *
   * @type {string}
   * @memberof ListingUpdate
   */
  depositMin?: string;
  /**
   *
   * @type {string}
   * @memberof ListingUpdate
   */
  depositMax?: string;
  /**
   *
   * @type {string}
   * @memberof ListingUpdate
   */
  depositHelperText?: string;
  /**
   *
   * @type {boolean}
   * @memberof ListingUpdate
   */
  disableUnitsAccordion?: boolean;
  /**
   *
   * @type {string}
   * @memberof ListingUpdate
   */
  leasingAgentEmail?: string;
  /**
   *
   * @type {string}
   * @memberof ListingUpdate
   */
  leasingAgentName?: string;
  /**
   *
   * @type {string}
   * @memberof ListingUpdate
   */
  leasingAgentOfficeHours?: string;
  /**
   *
   * @type {string}
   * @memberof ListingUpdate
   */
  leasingAgentPhone?: string;
  /**
   *
   * @type {string}
   * @memberof ListingUpdate
   */
  leasingAgentTitle?: string;
  /**
   *
   * @type {string}
   * @memberof ListingUpdate
   */
  name: string;
  /**
   *
   * @type {string}
   * @memberof ListingUpdate
   */
  postmarkedApplicationsReceivedByDate?: string;
  /**
   *
   * @type {string}
   * @memberof ListingUpdate
   */
  programRules?: string;
  /**
   *
   * @type {string}
   * @memberof ListingUpdate
   */
  rentalAssistance?: string;
  /**
   *
   * @type {string}
   * @memberof ListingUpdate
   */
  rentalHistory?: string;
  /**
   *
   * @type {string}
   * @memberof ListingUpdate
   */
  requiredDocuments?: string;
  /**
   *
   * @type {string}
   * @memberof ListingUpdate
   */
  specialNotes?: string;
  /**
   *
   * @type {number}
   * @memberof ListingUpdate
   */
  waitlistCurrentSize?: number;
  /**
   *
   * @type {number}
   * @memberof ListingUpdate
   */
  waitlistMaxSize?: number;
  /**
   *
   * @type {string}
   * @memberof ListingUpdate
   */
  whatToExpect?: string;
  /**
   *
   * @type {ListingsStatusEnum}
   * @memberof ListingUpdate
   */
  status: ListingsStatusEnum;
  /**
   *
   * @type {ReviewOrderTypeEnum}
   * @memberof ListingUpdate
   */
  reviewOrderType?: ReviewOrderTypeEnum;
  /**
   *
   * @type {boolean}
   * @memberof ListingUpdate
   */
  displayWaitlistSize: boolean;
  /**
   *
   * @type {string}
   * @memberof ListingUpdate
   */
  reservedCommunityDescription?: string;
  /**
   *
   * @type {number}
   * @memberof ListingUpdate
   */
  reservedCommunityMinAge?: number;
  /**
   *
   * @type {string}
   * @memberof ListingUpdate
   */
  resultLink?: string;
  /**
   *
   * @type {boolean}
   * @memberof ListingUpdate
   */
  isWaitlistOpen?: boolean;
  /**
   *
   * @type {number}
   * @memberof ListingUpdate
   */
  waitlistOpenSpots?: number;
  /**
   *
   * @type {boolean}
   * @memberof ListingUpdate
   */
  customMapPin?: boolean;
  /**
   *
   * @type {string}
   * @memberof ListingUpdate
   */
  contentUpdatedAt?: string;
  /**
   *
   * @type {string}
   * @memberof ListingUpdate
   */
  lotteryLastPublishedAt?: string;
  /**
   *
   * @type {string}
   * @memberof ListingUpdate
   */
  lotteryLastRunAt?: string;
  /**
   *
   * @type {LotteryStatusEnum}
   * @memberof ListingUpdate
   */
  lotteryStatus?: LotteryStatusEnum;
  /**
   *
   * @type {string}
   * @memberof ListingUpdate
   */
  lastApplicationUpdateAt?: string;
  /**
   *
   * @type {IdDTO}
   * @memberof ListingUpdate
   */
  jurisdictions: IdDTO;
  /**
   *
   * @type {IdDTO}
   * @memberof ListingUpdate
   */
  reservedCommunityTypes?: IdDTO;
  /**
   *
   * @type {string}
   * @memberof ListingUpdate
   */
  requestedChanges?: string;
  /**
   *
   * @type {string}
   * @memberof ListingUpdate
   */
  requestedChangesDate?: string;
  /**
   *
   * @type {boolean}
   * @memberof ListingUpdate
   */
  isExternal?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof ListingUpdate
   */
  lotteryOptIn?: boolean;
  /**
   *
   * @type {Array<IdDTO>}
   * @memberof ListingUpdate
   */
  listingMultiselectQuestions?: Array<IdDTO>;
  /**
   *
   * @type {Array<UnitCreate>}
   * @memberof ListingUpdate
   */
  units?: Array<UnitCreate>;
  /**
   *
   * @type {Array<ApplicationMethodCreate>}
   * @memberof ListingUpdate
   */
  applicationMethods?: Array<ApplicationMethodCreate>;
  /**
   *
   * @type {Array<AssetCreate>}
   * @memberof ListingUpdate
   */
  assets?: Array<AssetCreate>;
  /**
   *
   * @type {Array<UnitsSummaryCreate>}
   * @memberof ListingUpdate
   */
  unitsSummary: Array<UnitsSummaryCreate>;
  /**
   *
   * @type {Array<ListingImageCreate>}
   * @memberof ListingUpdate
   */
  listingImages?: Array<ListingImageCreate>;
  /**
   *
   * @type {AddressCreate}
   * @memberof ListingUpdate
   */
  listingsApplicationPickUpAddress?: AddressCreate;
  /**
   *
   * @type {AddressCreate}
   * @memberof ListingUpdate
   */
  listingsApplicationMailingAddress?: AddressCreate;
  /**
   *
   * @type {AddressCreate}
   * @memberof ListingUpdate
   */
  listingsApplicationDropOffAddress?: AddressCreate;
  /**
   *
   * @type {AddressCreate}
   * @memberof ListingUpdate
   */
  listingsLeasingAgentAddress?: AddressCreate;
  /**
   *
   * @type {AddressCreate}
   * @memberof ListingUpdate
   */
  listingsBuildingAddress?: AddressCreate;
  /**
   *
   * @type {AssetCreate}
   * @memberof ListingUpdate
   */
  listingsBuildingSelectionCriteriaFile?: AssetCreate;
  /**
   *
   * @type {AssetCreate}
   * @memberof ListingUpdate
   */
  listingsResult?: AssetCreate;
  /**
   *
   * @type {Array<ListingEventCreate>}
   * @memberof ListingUpdate
   */
  listingEvents: Array<ListingEventCreate>;
  /**
   *
   * @type {ListingFeatures}
   * @memberof ListingUpdate
   */
  listingFeatures?: ListingFeatures;
  /**
   *
   * @type {ListingUtilities}
   * @memberof ListingUpdate
   */
  listingUtilities?: ListingUtilities;
  /**
   *
   * @type {IdDTO}
   * @memberof ListingUpdate
   */
  requestedChangesUser?: IdDTO;
}

/**
 *
 * @export
 * @interface ListingUtilities
 */
export interface ListingUtilities {
  /**
   *
   * @type {boolean}
   * @memberof ListingUtilities
   */
  water?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof ListingUtilities
   */
  gas?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof ListingUtilities
   */
  trash?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof ListingUtilities
   */
  sewer?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof ListingUtilities
   */
  electricity?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof ListingUtilities
   */
  cable?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof ListingUtilities
   */
  phone?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof ListingUtilities
   */
  internet?: boolean;
}
/**
 *
 * @export
 * @enum {string}
 */

export const ListingViews = {
  Fundamentals: "fundamentals",
  Base: "base",
  Full: "full",
  Details: "details",
  Csv: "csv",
} as const;

export type ListingViews = (typeof ListingViews)[keyof typeof ListingViews];

/**
 *
 * @export
 * @interface ListingsQueryParams
 */
export interface ListingsQueryParams {
  /**
   *
   * @type {number}
   * @memberof ListingsQueryParams
   */
  page?: number;
  /**
   *
   * @type {number}
   * @memberof ListingsQueryParams
   */
  limit?: number;
  /**
   *
   * @type {Array<string>}
   * @memberof ListingsQueryParams
   */
  filter?: Array<string>;
  /**
   *
   * @type {ListingViews}
   * @memberof ListingsQueryParams
   */
  view?: ListingViews;
  /**
   *
   * @type {ListingOrderByKeys}
   * @memberof ListingsQueryParams
   */
  orderBy?: ListingOrderByKeys;
  /**
   *
   * @type {OrderByEnum}
   * @memberof ListingsQueryParams
   */
  orderDir?: OrderByEnum;
  /**
   *
   * @type {string}
   * @memberof ListingsQueryParams
   */
  search?: string;
}

/**
 *
 * @export
 * @interface ListingsRetrieveParams
 */
export interface ListingsRetrieveParams {
  /**
   *
   * @type {ListingViews}
   * @memberof ListingsRetrieveParams
   */
  view?: ListingViews;
}

/**
 *
 * @export
 * @enum {string}
 */

export const ListingsStatusEnum = {
  Active: "active",
  Pending: "pending",
  Closed: "closed",
  PendingReview: "pendingReview",
  ChangesRequested: "changesRequested",
} as const;

export type ListingsStatusEnum =
  (typeof ListingsStatusEnum)[keyof typeof ListingsStatusEnum];

/**
 *
 * @export
 * @interface Login
 */
export interface Login {
  /**
   *
   * @type {string}
   * @memberof Login
   */
  email: string;
  /**
   *
   * @type {string}
   * @memberof Login
   */
  password: string;
  /**
   *
   * @type {string}
   * @memberof Login
   */
  mfaCode?: string;
  /**
   *
   * @type {MfaType}
   * @memberof Login
   */
  mfaType?: MfaType;
  /**
   *
   * @type {string}
   * @memberof Login
   */
  reCaptchaToken?: string;
}

/**
 *
 * @export
 * @interface LoginViaSingleUseCode
 */
export interface LoginViaSingleUseCode {
  /**
   *
   * @type {string}
   * @memberof LoginViaSingleUseCode
   */
  email: string;
  /**
   *
   * @type {string}
   * @memberof LoginViaSingleUseCode
   */
  singleUseCode: string;
}
/**
 *
 * @export
 * @interface LotteryActivityLogItem
 */
export interface LotteryActivityLogItem {
  /**
   *
   * @type {string}
   * @memberof LotteryActivityLogItem
   */
  status: string;
  /**
   *
   * @type {string}
   * @memberof LotteryActivityLogItem
   */
  name: string;
  /**
   *
   * @type {string}
   * @memberof LotteryActivityLogItem
   */
  logDate: string;
}
/**
 *
 * @export
 * @enum {string}
 */

export const LotteryStatusEnum = {
  Errored: "errored",
  Ran: "ran",
  Approved: "approved",
  ReleasedToPartners: "releasedToPartners",
  PublishedToPublic: "publishedToPublic",
  Expired: "expired",
} as const;

export type LotteryStatusEnum =
  (typeof LotteryStatusEnum)[keyof typeof LotteryStatusEnum];

/**
 *
 * @export
 * @interface MapLayerDto
 */
export interface MapLayerDto {
  /**
   *
   * @type {string}
   * @memberof MapLayerDto
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof MapLayerDto
   */
  name: string;
  /**
   *
   * @type {string}
   * @memberof MapLayerDto
   */
  jurisdictionId: string;
}
/**
 *
 * @export
 * @enum {string}
 */

export const MfaType = {
  Sms: "sms",
  Email: "email",
} as const;

export type MfaType = (typeof MfaType)[keyof typeof MfaType];

/**
 *
 * @export
 * @interface MinMax
 */
export interface MinMax {
  /**
   *
   * @type {number}
   * @memberof MinMax
   */
  min: number;
  /**
   *
   * @type {number}
   * @memberof MinMax
   */
  max: number;
}
/**
 *
 * @export
 * @interface MinMaxCurrency
 */
export interface MinMaxCurrency {
  /**
   *
   * @type {string}
   * @memberof MinMaxCurrency
   */
  min: string;
  /**
   *
   * @type {string}
   * @memberof MinMaxCurrency
   */
  max: string;
}
/**
 *
 * @export
 * @interface MultiselectLink
 */
export interface MultiselectLink {
  /**
   *
   * @type {string}
   * @memberof MultiselectLink
   */
  title: string;
  /**
   *
   * @type {string}
   * @memberof MultiselectLink
   */
  url: string;
}
/**
 *
 * @export
 * @interface MultiselectOption
 */
export interface MultiselectOption {
  /**
   *
   * @type {string}
   * @memberof MultiselectOption
   */
  text: string;
  /**
   *
   * @type {string}
   * @memberof MultiselectOption
   */
  untranslatedText?: string;
  /**
   *
   * @type {number}
   * @memberof MultiselectOption
   */
  ordinal: number;
  /**
   *
   * @type {string}
   * @memberof MultiselectOption
   */
  description?: string;
  /**
   *
   * @type {Array<MultiselectLink>}
   * @memberof MultiselectOption
   */
  links?: Array<MultiselectLink>;
  /**
   *
   * @type {boolean}
   * @memberof MultiselectOption
   */
  collectAddress?: boolean;
  /**
   *
   * @type {ValidationMethodEnum}
   * @memberof MultiselectOption
   */
  validationMethod?: ValidationMethodEnum;
  /**
   *
   * @type {number}
   * @memberof MultiselectOption
   */
  radiusSize?: number;
  /**
   *
   * @type {boolean}
   * @memberof MultiselectOption
   */
  collectName?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof MultiselectOption
   */
  collectRelationship?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof MultiselectOption
   */
  exclusive?: boolean;
  /**
   *
   * @type {string}
   * @memberof MultiselectOption
   */
  mapLayerId?: string;
  /**
   *
   * @type {string}
   * @memberof MultiselectOption
   */
  mapPinPosition?: string;
}

/**
 *
 * @export
 * @interface MultiselectQuestion
 */
export interface MultiselectQuestion {
  /**
   *
   * @type {string}
   * @memberof MultiselectQuestion
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof MultiselectQuestion
   */
  createdAt: string;
  /**
   *
   * @type {string}
   * @memberof MultiselectQuestion
   */
  updatedAt: string;
  /**
   *
   * @type {string}
   * @memberof MultiselectQuestion
   */
  text: string;
  /**
   *
   * @type {string}
   * @memberof MultiselectQuestion
   */
  untranslatedText?: string;
  /**
   *
   * @type {string}
   * @memberof MultiselectQuestion
   */
  untranslatedOptOutText?: string;
  /**
   *
   * @type {string}
   * @memberof MultiselectQuestion
   */
  subText?: string;
  /**
   *
   * @type {string}
   * @memberof MultiselectQuestion
   */
  description?: string;
  /**
   *
   * @type {Array<MultiselectLink>}
   * @memberof MultiselectQuestion
   */
  links?: Array<MultiselectLink>;
  /**
   *
   * @type {Array<IdDTO>}
   * @memberof MultiselectQuestion
   */
  jurisdictions: Array<IdDTO>;
  /**
   *
   * @type {Array<MultiselectOption>}
   * @memberof MultiselectQuestion
   */
  options?: Array<MultiselectOption>;
  /**
   *
   * @type {string}
   * @memberof MultiselectQuestion
   */
  optOutText?: string;
  /**
   *
   * @type {boolean}
   * @memberof MultiselectQuestion
   */
  hideFromListing?: boolean;
  /**
   *
   * @type {MultiselectQuestionsApplicationSectionEnum}
   * @memberof MultiselectQuestion
   */
  applicationSection: MultiselectQuestionsApplicationSectionEnum;
}

/**
 *
 * @export
 * @interface MultiselectQuestionCreate
 */
export interface MultiselectQuestionCreate {
  /**
   *
   * @type {string}
   * @memberof MultiselectQuestionCreate
   */
  text: string;
  /**
   *
   * @type {string}
   * @memberof MultiselectQuestionCreate
   */
  untranslatedOptOutText?: string;
  /**
   *
   * @type {string}
   * @memberof MultiselectQuestionCreate
   */
  subText?: string;
  /**
   *
   * @type {string}
   * @memberof MultiselectQuestionCreate
   */
  description?: string;
  /**
   *
   * @type {Array<MultiselectLink>}
   * @memberof MultiselectQuestionCreate
   */
  links?: Array<MultiselectLink>;
  /**
   *
   * @type {Array<IdDTO>}
   * @memberof MultiselectQuestionCreate
   */
  jurisdictions: Array<IdDTO>;
  /**
   *
   * @type {Array<MultiselectOption>}
   * @memberof MultiselectQuestionCreate
   */
  options?: Array<MultiselectOption>;
  /**
   *
   * @type {string}
   * @memberof MultiselectQuestionCreate
   */
  optOutText?: string;
  /**
   *
   * @type {boolean}
   * @memberof MultiselectQuestionCreate
   */
  hideFromListing?: boolean;
  /**
   *
   * @type {MultiselectQuestionsApplicationSectionEnum}
   * @memberof MultiselectQuestionCreate
   */
  applicationSection: MultiselectQuestionsApplicationSectionEnum;
}

/**
 *
 * @export
 * @interface MultiselectQuestionFilterParams
 */
export interface MultiselectQuestionFilterParams {
  /**
   *
   * @type {string}
   * @memberof MultiselectQuestionFilterParams
   */
  $comparison: MultiselectQuestionFilterParamsComparisonEnum;
  /**
   *
   * @type {string}
   * @memberof MultiselectQuestionFilterParams
   */
  jurisdiction?: string;
  /**
   *
   * @type {MultiselectQuestionsApplicationSectionEnum}
   * @memberof MultiselectQuestionFilterParams
   */
  applicationSection?: MultiselectQuestionsApplicationSectionEnum;
}

export const MultiselectQuestionFilterParamsComparisonEnum = {
  Equal: "=",
  NotEqual: "<>",
  In: "IN",
  GreaterThanOrEqualTo: ">=",
  LessThanOrEqualTo: "<=",
  Na: "NA",
} as const;

export type MultiselectQuestionFilterParamsComparisonEnum =
  (typeof MultiselectQuestionFilterParamsComparisonEnum)[keyof typeof MultiselectQuestionFilterParamsComparisonEnum];

/**
 *
 * @export
 * @interface MultiselectQuestionQueryParams
 */
export interface MultiselectQuestionQueryParams {
  /**
   *
   * @type {Array<string>}
   * @memberof MultiselectQuestionQueryParams
   */
  filter?: Array<string>;
}
/**
 *
 * @export
 * @interface MultiselectQuestionUpdate
 */
export interface MultiselectQuestionUpdate {
  /**
   *
   * @type {string}
   * @memberof MultiselectQuestionUpdate
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof MultiselectQuestionUpdate
   */
  text: string;
  /**
   *
   * @type {string}
   * @memberof MultiselectQuestionUpdate
   */
  untranslatedOptOutText?: string;
  /**
   *
   * @type {string}
   * @memberof MultiselectQuestionUpdate
   */
  subText?: string;
  /**
   *
   * @type {string}
   * @memberof MultiselectQuestionUpdate
   */
  description?: string;
  /**
   *
   * @type {Array<MultiselectLink>}
   * @memberof MultiselectQuestionUpdate
   */
  links?: Array<MultiselectLink>;
  /**
   *
   * @type {Array<IdDTO>}
   * @memberof MultiselectQuestionUpdate
   */
  jurisdictions: Array<IdDTO>;
  /**
   *
   * @type {Array<MultiselectOption>}
   * @memberof MultiselectQuestionUpdate
   */
  options?: Array<MultiselectOption>;
  /**
   *
   * @type {string}
   * @memberof MultiselectQuestionUpdate
   */
  optOutText?: string;
  /**
   *
   * @type {boolean}
   * @memberof MultiselectQuestionUpdate
   */
  hideFromListing?: boolean;
  /**
   *
   * @type {MultiselectQuestionsApplicationSectionEnum}
   * @memberof MultiselectQuestionUpdate
   */
  applicationSection: MultiselectQuestionsApplicationSectionEnum;
}

/**
 *
 * @export
 * @enum {string}
 */

export const MultiselectQuestionsApplicationSectionEnum = {
  Programs: "programs",
  Preferences: "preferences",
} as const;

export type MultiselectQuestionsApplicationSectionEnum =
  (typeof MultiselectQuestionsApplicationSectionEnum)[keyof typeof MultiselectQuestionsApplicationSectionEnum];

/**
 *
 * @export
 * @enum {string}
 */

export const OrderByEnum = {
  Asc: "asc",
  Desc: "desc",
} as const;

export type OrderByEnum = (typeof OrderByEnum)[keyof typeof OrderByEnum];

/**
 *
 * @export
 * @interface PaginatedAfsDto
 */
export interface PaginatedAfsDto {
  /**
   *
   * @type {Array<ApplicationFlaggedSet>}
   * @memberof PaginatedAfsDto
   */
  items: Array<ApplicationFlaggedSet>;
  /**
   *
   * @type {ApplicationFlaggedSetPaginationMeta}
   * @memberof PaginatedAfsDto
   */
  meta: ApplicationFlaggedSetPaginationMeta;
}
/**
 *
 * @export
 * @interface PaginatedApplicationDto
 */
export interface PaginatedApplicationDto {
  /**
   *
   * @type {Array<Application>}
   * @memberof PaginatedApplicationDto
   */
  items: Array<Application>;
  /**
   *
   * @type {PaginationMeta}
   * @memberof PaginatedApplicationDto
   */
  meta: PaginationMeta;
}
/**
 *
 * @export
 * @interface PaginatedListingDto
 */
export interface PaginatedListingDto {
  /**
   *
   * @type {Array<Listing>}
   * @memberof PaginatedListingDto
   */
  items: Array<Listing>;
  /**
   *
   * @type {PaginationMeta}
   * @memberof PaginatedListingDto
   */
  meta: PaginationMeta;
}
/**
 *
 * @export
 * @interface PaginatedUserDto
 */
export interface PaginatedUserDto {
  /**
   *
   * @type {Array<User>}
   * @memberof PaginatedUserDto
   */
  items: Array<User>;
  /**
   *
   * @type {PaginationMeta}
   * @memberof PaginatedUserDto
   */
  meta: PaginationMeta;
}
/**
 *
 * @export
 * @interface PaginationAllowsAllQueryParams
 */
export interface PaginationAllowsAllQueryParams {
  /**
   *
   * @type {number}
   * @memberof PaginationAllowsAllQueryParams
   */
  page?: number;
  /**
   *
   * @type {number}
   * @memberof PaginationAllowsAllQueryParams
   */
  limit?: number;
}
/**
 *
 * @export
 * @interface PaginationMeta
 */
export interface PaginationMeta {
  /**
   *
   * @type {number}
   * @memberof PaginationMeta
   */
  currentPage: number;
  /**
   *
   * @type {number}
   * @memberof PaginationMeta
   */
  itemCount: number;
  /**
   *
   * @type {number}
   * @memberof PaginationMeta
   */
  itemsPerPage: number;
  /**
   *
   * @type {number}
   * @memberof PaginationMeta
   */
  totalItems: number;
  /**
   *
   * @type {number}
   * @memberof PaginationMeta
   */
  totalPages: number;
}
/**
 *
 * @export
 * @interface PaperApplication
 */
export interface PaperApplication {
  /**
   *
   * @type {string}
   * @memberof PaperApplication
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof PaperApplication
   */
  createdAt: string;
  /**
   *
   * @type {string}
   * @memberof PaperApplication
   */
  updatedAt: string;
  /**
   *
   * @type {LanguagesEnum}
   * @memberof PaperApplication
   */
  language: LanguagesEnum;
  /**
   *
   * @type {Asset}
   * @memberof PaperApplication
   */
  assets: Asset;
}

/**
 *
 * @export
 * @interface PaperApplicationCreate
 */
export interface PaperApplicationCreate {
  /**
   *
   * @type {LanguagesEnum}
   * @memberof PaperApplicationCreate
   */
  language: LanguagesEnum;
  /**
   *
   * @type {AssetCreate}
   * @memberof PaperApplicationCreate
   */
  assets?: AssetCreate;
}

/**
 *
 * @export
 * @interface PublicAppsCount
 */
export interface PublicAppsCount {
  /**
   *
   * @type {number}
   * @memberof PublicAppsCount
   */
  total: number;
  /**
   *
   * @type {number}
   * @memberof PublicAppsCount
   */
  lottery: number;
  /**
   *
   * @type {number}
   * @memberof PublicAppsCount
   */
  closed: number;
  /**
   *
   * @type {number}
   * @memberof PublicAppsCount
   */
  open: number;
}
/**
 *
 * @export
 * @interface PublicAppsFiltered
 */
export interface PublicAppsFiltered {
  /**
   *
   * @type {string}
   * @memberof PublicAppsFiltered
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof PublicAppsFiltered
   */
  createdAt: string;
  /**
   *
   * @type {string}
   * @memberof PublicAppsFiltered
   */
  updatedAt: string;
  /**
   *
   * @type {string}
   * @memberof PublicAppsFiltered
   */
  deletedAt?: string;
  /**
   *
   * @type {string}
   * @memberof PublicAppsFiltered
   */
  appUrl?: string;
  /**
   *
   * @type {boolean}
   * @memberof PublicAppsFiltered
   */
  additionalPhone?: boolean;
  /**
   *
   * @type {string}
   * @memberof PublicAppsFiltered
   */
  additionalPhoneNumber?: string;
  /**
   *
   * @type {string}
   * @memberof PublicAppsFiltered
   */
  additionalPhoneNumberType?: string;
  /**
   *
   * @type {Array<string>}
   * @memberof PublicAppsFiltered
   */
  contactPreferences: Array<string>;
  /**
   *
   * @type {number}
   * @memberof PublicAppsFiltered
   */
  householdSize: number;
  /**
   *
   * @type {string}
   * @memberof PublicAppsFiltered
   */
  housingStatus?: string;
  /**
   *
   * @type {boolean}
   * @memberof PublicAppsFiltered
   */
  sendMailToMailingAddress?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof PublicAppsFiltered
   */
  householdExpectingChanges?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof PublicAppsFiltered
   */
  householdStudent?: boolean;
  /**
   *
   * @type {Array<string>}
   * @memberof PublicAppsFiltered
   */
  incomeVouchers?: Array<string>;
  /**
   *
   * @type {string}
   * @memberof PublicAppsFiltered
   */
  income?: string;
  /**
   *
   * @type {IncomePeriodEnum}
   * @memberof PublicAppsFiltered
   */
  incomePeriod?: IncomePeriodEnum;
  /**
   *
   * @type {ApplicationStatusEnum}
   * @memberof PublicAppsFiltered
   */
  status: ApplicationStatusEnum;
  /**
   *
   * @type {LanguagesEnum}
   * @memberof PublicAppsFiltered
   */
  language?: LanguagesEnum;
  /**
   *
   * @type {boolean}
   * @memberof PublicAppsFiltered
   */
  acceptedTerms?: boolean;
  /**
   *
   * @type {ApplicationSubmissionTypeEnum}
   * @memberof PublicAppsFiltered
   */
  submissionType: ApplicationSubmissionTypeEnum;
  /**
   *
   * @type {string}
   * @memberof PublicAppsFiltered
   */
  submissionDate?: string;
  /**
   *
   * @type {string}
   * @memberof PublicAppsFiltered
   */
  receivedBy?: string;
  /**
   *
   * @type {string}
   * @memberof PublicAppsFiltered
   */
  receivedAt?: string;
  /**
   *
   * @type {boolean}
   * @memberof PublicAppsFiltered
   */
  markedAsDuplicate: boolean;
  /**
   *
   * @type {boolean}
   * @memberof PublicAppsFiltered
   */
  flagged?: boolean;
  /**
   *
   * @type {string}
   * @memberof PublicAppsFiltered
   */
  confirmationCode: string;
  /**
   *
   * @type {ApplicationReviewStatusEnum}
   * @memberof PublicAppsFiltered
   */
  reviewStatus?: ApplicationReviewStatusEnum;
  /**
   *
   * @type {Address}
   * @memberof PublicAppsFiltered
   */
  applicationsMailingAddress: Address;
  /**
   *
   * @type {Address}
   * @memberof PublicAppsFiltered
   */
  applicationsAlternateAddress: Address;
  /**
   *
   * @type {Accessibility}
   * @memberof PublicAppsFiltered
   */
  accessibility: Accessibility;
  /**
   *
   * @type {Demographic}
   * @memberof PublicAppsFiltered
   */
  demographics: Demographic;
  /**
   *
   * @type {Array<UnitType>}
   * @memberof PublicAppsFiltered
   */
  preferredUnitTypes: Array<UnitType>;
  /**
   *
   * @type {Applicant}
   * @memberof PublicAppsFiltered
   */
  applicant: Applicant;
  /**
   *
   * @type {AlternateContact}
   * @memberof PublicAppsFiltered
   */
  alternateContact: AlternateContact;
  /**
   *
   * @type {Array<HouseholdMember>}
   * @memberof PublicAppsFiltered
   */
  householdMember: Array<HouseholdMember>;
  /**
   *
   * @type {Array<ApplicationMultiselectQuestion>}
   * @memberof PublicAppsFiltered
   */
  preferences?: Array<ApplicationMultiselectQuestion>;
  /**
   *
   * @type {Array<ApplicationMultiselectQuestion>}
   * @memberof PublicAppsFiltered
   */
  programs?: Array<ApplicationMultiselectQuestion>;
  /**
   *
   * @type {Array<ApplicationLotteryPosition>}
   * @memberof PublicAppsFiltered
   */
  applicationLotteryPositions: Array<ApplicationLotteryPosition>;
  /**
   *
   * @type {Listing}
   * @memberof PublicAppsFiltered
   */
  listings: Listing;
}

/**
 *
 * @export
 * @interface PublicAppsViewResponse
 */
export interface PublicAppsViewResponse {
  /**
   *
   * @type {Array<PublicAppsFiltered>}
   * @memberof PublicAppsViewResponse
   */
  displayApplications: Array<PublicAppsFiltered>;
  /**
   *
   * @type {PublicAppsCount}
   * @memberof PublicAppsViewResponse
   */
  applicationsCount: PublicAppsCount;
}
/**
 *
 * @export
 * @interface PublicLotteryResult
 */
export interface PublicLotteryResult {
  /**
   *
   * @type {number}
   * @memberof PublicLotteryResult
   */
  ordinal: number;
  /**
   *
   * @type {string}
   * @memberof PublicLotteryResult
   */
  multiselectQuestionId?: string;
}
/**
 *
 * @export
 * @interface PublicLotteryTotal
 */
export interface PublicLotteryTotal {
  /**
   *
   * @type {number}
   * @memberof PublicLotteryTotal
   */
  total: number;
  /**
   *
   * @type {string}
   * @memberof PublicLotteryTotal
   */
  multiselectQuestionId?: string;
}
/**
 *
 * @export
 * @interface RequestMfaCode
 */
export interface RequestMfaCode {
  /**
   *
   * @type {string}
   * @memberof RequestMfaCode
   */
  email: string;
  /**
   *
   * @type {string}
   * @memberof RequestMfaCode
   */
  password: string;
  /**
   *
   * @type {MfaType}
   * @memberof RequestMfaCode
   */
  mfaType: MfaType;
  /**
   *
   * @type {string}
   * @memberof RequestMfaCode
   */
  phoneNumber?: string;
}

/**
 *
 * @export
 * @interface RequestMfaCodeResponse
 */
export interface RequestMfaCodeResponse {
  /**
   *
   * @type {string}
   * @memberof RequestMfaCodeResponse
   */
  phoneNumber?: string;
  /**
   *
   * @type {string}
   * @memberof RequestMfaCodeResponse
   */
  email?: string;
  /**
   *
   * @type {boolean}
   * @memberof RequestMfaCodeResponse
   */
  phoneNumberVerified?: boolean;
}
/**
 *
 * @export
 * @interface RequestSingleUseCode
 */
export interface RequestSingleUseCode {
  /**
   *
   * @type {string}
   * @memberof RequestSingleUseCode
   */
  email: string;
}
/**
 *
 * @export
 * @interface ReservedCommunityType
 */
export interface ReservedCommunityType {
  /**
   *
   * @type {string}
   * @memberof ReservedCommunityType
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof ReservedCommunityType
   */
  createdAt: string;
  /**
   *
   * @type {string}
   * @memberof ReservedCommunityType
   */
  updatedAt: string;
  /**
   *
   * @type {string}
   * @memberof ReservedCommunityType
   */
  name: string;
  /**
   *
   * @type {string}
   * @memberof ReservedCommunityType
   */
  description?: string;
  /**
   *
   * @type {IdDTO}
   * @memberof ReservedCommunityType
   */
  jurisdictions: IdDTO;
}
/**
 *
 * @export
 * @interface ReservedCommunityTypeCreate
 */
export interface ReservedCommunityTypeCreate {
  /**
   *
   * @type {string}
   * @memberof ReservedCommunityTypeCreate
   */
  name: string;
  /**
   *
   * @type {string}
   * @memberof ReservedCommunityTypeCreate
   */
  description?: string;
  /**
   *
   * @type {IdDTO}
   * @memberof ReservedCommunityTypeCreate
   */
  jurisdictions: IdDTO;
}
/**
 *
 * @export
 * @interface ReservedCommunityTypeQueryParams
 */
export interface ReservedCommunityTypeQueryParams {
  /**
   *
   * @type {string}
   * @memberof ReservedCommunityTypeQueryParams
   */
  jurisdictionId?: string;
}
/**
 *
 * @export
 * @interface ReservedCommunityTypeUpdate
 */
export interface ReservedCommunityTypeUpdate {
  /**
   *
   * @type {string}
   * @memberof ReservedCommunityTypeUpdate
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof ReservedCommunityTypeUpdate
   */
  name: string;
  /**
   *
   * @type {string}
   * @memberof ReservedCommunityTypeUpdate
   */
  description?: string;
}
/**
 *
 * @export
 * @enum {string}
 */

export const ReviewOrderTypeEnum = {
  Lottery: "lottery",
  FirstComeFirstServe: "firstComeFirstServe",
  Waitlist: "waitlist",
} as const;

export type ReviewOrderTypeEnum =
  (typeof ReviewOrderTypeEnum)[keyof typeof ReviewOrderTypeEnum];

/**
 *
 * @export
 * @enum {string}
 */

export const RuleEnum = {
  NameAndDob: "nameAndDOB",
  Email: "email",
  Combination: "combination",
} as const;

export type RuleEnum = (typeof RuleEnum)[keyof typeof RuleEnum];

/**
 *
 * @export
 * @interface SuccessDTO
 */
export interface SuccessDTO {
  /**
   *
   * @type {boolean}
   * @memberof SuccessDTO
   */
  success: boolean;
}
/**
 *
 * @export
 * @interface TextInput
 */
export interface TextInput {
  /**
   *
   * @type {InputType}
   * @memberof TextInput
   */
  type: InputType;
  /**
   *
   * @type {string}
   * @memberof TextInput
   */
  key: string;
  /**
   *
   * @type {string}
   * @memberof TextInput
   */
  value: string;
}

/**
 *
 * @export
 * @interface Unit
 */
export interface Unit {
  /**
   *
   * @type {string}
   * @memberof Unit
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof Unit
   */
  createdAt: string;
  /**
   *
   * @type {string}
   * @memberof Unit
   */
  updatedAt: string;
  /**
   *
   * @type {AmiChart}
   * @memberof Unit
   */
  amiChart?: AmiChart;
  /**
   *
   * @type {string}
   * @memberof Unit
   */
  amiPercentage?: string;
  /**
   *
   * @type {string}
   * @memberof Unit
   */
  annualIncomeMin?: string;
  /**
   *
   * @type {string}
   * @memberof Unit
   */
  monthlyIncomeMin?: string;
  /**
   *
   * @type {number}
   * @memberof Unit
   */
  floor?: number;
  /**
   *
   * @type {string}
   * @memberof Unit
   */
  annualIncomeMax?: string;
  /**
   *
   * @type {number}
   * @memberof Unit
   */
  maxOccupancy?: number;
  /**
   *
   * @type {number}
   * @memberof Unit
   */
  minOccupancy?: number;
  /**
   *
   * @type {string}
   * @memberof Unit
   */
  monthlyRent?: string;
  /**
   *
   * @type {number}
   * @memberof Unit
   */
  numBathrooms?: number;
  /**
   *
   * @type {number}
   * @memberof Unit
   */
  numBedrooms?: number;
  /**
   *
   * @type {string}
   * @memberof Unit
   */
  number?: string;
  /**
   *
   * @type {string}
   * @memberof Unit
   */
  sqFeet?: string;
  /**
   *
   * @type {string}
   * @memberof Unit
   */
  monthlyRentAsPercentOfIncome?: string;
  /**
   *
   * @type {boolean}
   * @memberof Unit
   */
  bmrProgramChart?: boolean;
  /**
   *
   * @type {UnitType}
   * @memberof Unit
   */
  unitTypes?: UnitType;
  /**
   *
   * @type {UnitRentType}
   * @memberof Unit
   */
  unitRentTypes?: UnitRentType;
  /**
   *
   * @type {UnitAccessibilityPriorityType}
   * @memberof Unit
   */
  unitAccessibilityPriorityTypes?: UnitAccessibilityPriorityType;
  /**
   *
   * @type {UnitAmiChartOverride}
   * @memberof Unit
   */
  unitAmiChartOverrides?: UnitAmiChartOverride;
}
/**
 *
 * @export
 * @interface UnitAccessibilityPriorityType
 */
export interface UnitAccessibilityPriorityType {
  /**
   *
   * @type {string}
   * @memberof UnitAccessibilityPriorityType
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof UnitAccessibilityPriorityType
   */
  createdAt: string;
  /**
   *
   * @type {string}
   * @memberof UnitAccessibilityPriorityType
   */
  updatedAt: string;
  /**
   *
   * @type {string}
   * @memberof UnitAccessibilityPriorityType
   */
  name: string;
}
/**
 *
 * @export
 * @interface UnitAccessibilityPriorityTypeCreate
 */
export interface UnitAccessibilityPriorityTypeCreate {
  /**
   *
   * @type {string}
   * @memberof UnitAccessibilityPriorityTypeCreate
   */
  name: string;
}
/**
 *
 * @export
 * @interface UnitAccessibilityPriorityTypeUpdate
 */
export interface UnitAccessibilityPriorityTypeUpdate {
  /**
   *
   * @type {string}
   * @memberof UnitAccessibilityPriorityTypeUpdate
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof UnitAccessibilityPriorityTypeUpdate
   */
  name: string;
}
/**
 *
 * @export
 * @interface UnitAmiChartOverride
 */
export interface UnitAmiChartOverride {
  /**
   *
   * @type {string}
   * @memberof UnitAmiChartOverride
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof UnitAmiChartOverride
   */
  createdAt: string;
  /**
   *
   * @type {string}
   * @memberof UnitAmiChartOverride
   */
  updatedAt: string;
  /**
   *
   * @type {Array<AmiChartItem>}
   * @memberof UnitAmiChartOverride
   */
  items: Array<AmiChartItem>;
}
/**
 *
 * @export
 * @interface UnitAmiChartOverrideCreate
 */
export interface UnitAmiChartOverrideCreate {
  /**
   *
   * @type {Array<AmiChartItem>}
   * @memberof UnitAmiChartOverrideCreate
   */
  items: Array<AmiChartItem>;
}
/**
 *
 * @export
 * @interface UnitCreate
 */
export interface UnitCreate {
  /**
   *
   * @type {string}
   * @memberof UnitCreate
   */
  amiPercentage?: string;
  /**
   *
   * @type {string}
   * @memberof UnitCreate
   */
  annualIncomeMin?: string;
  /**
   *
   * @type {string}
   * @memberof UnitCreate
   */
  monthlyIncomeMin?: string;
  /**
   *
   * @type {number}
   * @memberof UnitCreate
   */
  floor?: number;
  /**
   *
   * @type {string}
   * @memberof UnitCreate
   */
  annualIncomeMax?: string;
  /**
   *
   * @type {number}
   * @memberof UnitCreate
   */
  maxOccupancy?: number;
  /**
   *
   * @type {number}
   * @memberof UnitCreate
   */
  minOccupancy?: number;
  /**
   *
   * @type {string}
   * @memberof UnitCreate
   */
  monthlyRent?: string;
  /**
   *
   * @type {number}
   * @memberof UnitCreate
   */
  numBathrooms?: number;
  /**
   *
   * @type {number}
   * @memberof UnitCreate
   */
  numBedrooms?: number;
  /**
   *
   * @type {string}
   * @memberof UnitCreate
   */
  number?: string;
  /**
   *
   * @type {string}
   * @memberof UnitCreate
   */
  sqFeet?: string;
  /**
   *
   * @type {string}
   * @memberof UnitCreate
   */
  monthlyRentAsPercentOfIncome?: string;
  /**
   *
   * @type {boolean}
   * @memberof UnitCreate
   */
  bmrProgramChart?: boolean;
  /**
   *
   * @type {IdDTO}
   * @memberof UnitCreate
   */
  unitTypes?: IdDTO;
  /**
   *
   * @type {IdDTO}
   * @memberof UnitCreate
   */
  amiChart?: IdDTO;
  /**
   *
   * @type {IdDTO}
   * @memberof UnitCreate
   */
  unitAccessibilityPriorityTypes?: IdDTO;
  /**
   *
   * @type {IdDTO}
   * @memberof UnitCreate
   */
  unitRentTypes?: IdDTO;
  /**
   *
   * @type {UnitAmiChartOverrideCreate}
   * @memberof UnitCreate
   */
  unitAmiChartOverrides?: UnitAmiChartOverrideCreate;
}
/**
 *
 * @export
 * @interface UnitRentType
 */
export interface UnitRentType {
  /**
   *
   * @type {string}
   * @memberof UnitRentType
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof UnitRentType
   */
  createdAt: string;
  /**
   *
   * @type {string}
   * @memberof UnitRentType
   */
  updatedAt: string;
  /**
   *
   * @type {UnitRentTypeEnum}
   * @memberof UnitRentType
   */
  name: UnitRentTypeEnum;
}

/**
 *
 * @export
 * @interface UnitRentTypeCreate
 */
export interface UnitRentTypeCreate {
  /**
   *
   * @type {UnitRentTypeEnum}
   * @memberof UnitRentTypeCreate
   */
  name: UnitRentTypeEnum;
}

/**
 *
 * @export
 * @enum {string}
 */

export const UnitRentTypeEnum = {
  Fixed: "fixed",
  PercentageOfIncome: "percentageOfIncome",
} as const;

export type UnitRentTypeEnum =
  (typeof UnitRentTypeEnum)[keyof typeof UnitRentTypeEnum];

/**
 *
 * @export
 * @interface UnitRentTypeUpdate
 */
export interface UnitRentTypeUpdate {
  /**
   *
   * @type {string}
   * @memberof UnitRentTypeUpdate
   */
  id: string;
  /**
   *
   * @type {UnitRentTypeEnum}
   * @memberof UnitRentTypeUpdate
   */
  name: UnitRentTypeEnum;
}

/**
 *
 * @export
 * @interface UnitSummary
 */
export interface UnitSummary {
  /**
   *
   * @type {UnitType}
   * @memberof UnitSummary
   */
  unitTypes: UnitType;
  /**
   *
   * @type {MinMaxCurrency}
   * @memberof UnitSummary
   */
  minIncomeRange: MinMaxCurrency;
  /**
   *
   * @type {MinMax}
   * @memberof UnitSummary
   */
  occupancyRange: MinMax;
  /**
   *
   * @type {MinMax}
   * @memberof UnitSummary
   */
  rentAsPercentIncomeRange: MinMax;
  /**
   *
   * @type {MinMaxCurrency}
   * @memberof UnitSummary
   */
  rentRange: MinMaxCurrency;
  /**
   *
   * @type {number}
   * @memberof UnitSummary
   */
  totalAvailable: number;
  /**
   *
   * @type {MinMax}
   * @memberof UnitSummary
   */
  areaRange: MinMax;
  /**
   *
   * @type {MinMax}
   * @memberof UnitSummary
   */
  floorRange?: MinMax;
}
/**
 *
 * @export
 * @interface UnitSummaryByAMI
 */
export interface UnitSummaryByAMI {
  /**
   *
   * @type {string}
   * @memberof UnitSummaryByAMI
   */
  percent: string;
  /**
   *
   * @type {Array<UnitSummary>}
   * @memberof UnitSummaryByAMI
   */
  byUnitType: Array<UnitSummary>;
}
/**
 *
 * @export
 * @interface UnitType
 */
export interface UnitType {
  /**
   *
   * @type {string}
   * @memberof UnitType
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof UnitType
   */
  createdAt: string;
  /**
   *
   * @type {string}
   * @memberof UnitType
   */
  updatedAt: string;
  /**
   *
   * @type {UnitTypeEnum}
   * @memberof UnitType
   */
  name: UnitTypeEnum;
  /**
   *
   * @type {number}
   * @memberof UnitType
   */
  numBedrooms: number;
}

/**
 *
 * @export
 * @interface UnitTypeCreate
 */
export interface UnitTypeCreate {
  /**
   *
   * @type {UnitTypeEnum}
   * @memberof UnitTypeCreate
   */
  name: UnitTypeEnum;
  /**
   *
   * @type {number}
   * @memberof UnitTypeCreate
   */
  numBedrooms: number;
}

/**
 *
 * @export
 * @enum {string}
 */

export const UnitTypeEnum = {
  Studio: "studio",
  OneBdrm: "oneBdrm",
  TwoBdrm: "twoBdrm",
  ThreeBdrm: "threeBdrm",
  FourBdrm: "fourBdrm",
  Sro: "SRO",
  FiveBdrm: "fiveBdrm",
} as const;

export type UnitTypeEnum = (typeof UnitTypeEnum)[keyof typeof UnitTypeEnum];

/**
 *
 * @export
 * @interface UnitTypeUpdate
 */
export interface UnitTypeUpdate {
  /**
   *
   * @type {string}
   * @memberof UnitTypeUpdate
   */
  id: string;
  /**
   *
   * @type {UnitTypeEnum}
   * @memberof UnitTypeUpdate
   */
  name: UnitTypeEnum;
  /**
   *
   * @type {number}
   * @memberof UnitTypeUpdate
   */
  numBedrooms: number;
}

/**
 *
 * @export
 * @interface UnitsSummarized
 */
export interface UnitsSummarized {
  /**
   *
   * @type {Array<UnitType>}
   * @memberof UnitsSummarized
   */
  unitTypes: Array<UnitType>;
  /**
   *
   * @type {Array<UnitAccessibilityPriorityType>}
   * @memberof UnitsSummarized
   */
  priorityTypes: Array<UnitAccessibilityPriorityType>;
  /**
   *
   * @type {Array<string>}
   * @memberof UnitsSummarized
   */
  amiPercentages: Array<string>;
  /**
   *
   * @type {Array<UnitSummary>}
   * @memberof UnitsSummarized
   */
  byUnitTypeAndRent: Array<UnitSummary>;
  /**
   *
   * @type {Array<UnitSummary>}
   * @memberof UnitsSummarized
   */
  byUnitType: Array<UnitSummary>;
  /**
   *
   * @type {Array<UnitSummaryByAMI>}
   * @memberof UnitsSummarized
   */
  byAMI: Array<UnitSummaryByAMI>;
  /**
   *
   * @type {HMI}
   * @memberof UnitsSummarized
   */
  hmi: HMI;
}
/**
 *
 * @export
 * @interface UnitsSummary
 */
export interface UnitsSummary {
  /**
   *
   * @type {string}
   * @memberof UnitsSummary
   */
  id: string;
  /**
   *
   * @type {IdDTO}
   * @memberof UnitsSummary
   */
  unitTypes: IdDTO;
  /**
   *
   * @type {number}
   * @memberof UnitsSummary
   */
  monthlyRentMin?: number;
  /**
   *
   * @type {number}
   * @memberof UnitsSummary
   */
  monthlyRentMax?: number;
  /**
   *
   * @type {string}
   * @memberof UnitsSummary
   */
  monthlyRentAsPercentOfIncome?: string;
  /**
   *
   * @type {number}
   * @memberof UnitsSummary
   */
  amiPercentage?: number;
  /**
   *
   * @type {string}
   * @memberof UnitsSummary
   */
  minimumIncomeMin?: string;
  /**
   *
   * @type {string}
   * @memberof UnitsSummary
   */
  minimumIncomeMax?: string;
  /**
   *
   * @type {number}
   * @memberof UnitsSummary
   */
  maxOccupancy?: number;
  /**
   *
   * @type {number}
   * @memberof UnitsSummary
   */
  minOccupancy?: number;
  /**
   *
   * @type {number}
   * @memberof UnitsSummary
   */
  floorMin?: number;
  /**
   *
   * @type {number}
   * @memberof UnitsSummary
   */
  floorMax?: number;
  /**
   *
   * @type {string}
   * @memberof UnitsSummary
   */
  sqFeetMin?: string;
  /**
   *
   * @type {string}
   * @memberof UnitsSummary
   */
  sqFeetMax?: string;
  /**
   *
   * @type {IdDTO}
   * @memberof UnitsSummary
   */
  unitAccessibilityPriorityTypes?: IdDTO;
  /**
   *
   * @type {number}
   * @memberof UnitsSummary
   */
  totalCount?: number;
  /**
   *
   * @type {number}
   * @memberof UnitsSummary
   */
  totalAvailable?: number;
}
/**
 *
 * @export
 * @interface UnitsSummaryCreate
 */
export interface UnitsSummaryCreate {
  /**
   *
   * @type {IdDTO}
   * @memberof UnitsSummaryCreate
   */
  unitTypes: IdDTO;
  /**
   *
   * @type {number}
   * @memberof UnitsSummaryCreate
   */
  monthlyRentMin?: number;
  /**
   *
   * @type {number}
   * @memberof UnitsSummaryCreate
   */
  monthlyRentMax?: number;
  /**
   *
   * @type {string}
   * @memberof UnitsSummaryCreate
   */
  monthlyRentAsPercentOfIncome?: string;
  /**
   *
   * @type {number}
   * @memberof UnitsSummaryCreate
   */
  amiPercentage?: number;
  /**
   *
   * @type {string}
   * @memberof UnitsSummaryCreate
   */
  minimumIncomeMin?: string;
  /**
   *
   * @type {string}
   * @memberof UnitsSummaryCreate
   */
  minimumIncomeMax?: string;
  /**
   *
   * @type {number}
   * @memberof UnitsSummaryCreate
   */
  maxOccupancy?: number;
  /**
   *
   * @type {number}
   * @memberof UnitsSummaryCreate
   */
  minOccupancy?: number;
  /**
   *
   * @type {number}
   * @memberof UnitsSummaryCreate
   */
  floorMin?: number;
  /**
   *
   * @type {number}
   * @memberof UnitsSummaryCreate
   */
  floorMax?: number;
  /**
   *
   * @type {string}
   * @memberof UnitsSummaryCreate
   */
  sqFeetMin?: string;
  /**
   *
   * @type {string}
   * @memberof UnitsSummaryCreate
   */
  sqFeetMax?: string;
  /**
   *
   * @type {IdDTO}
   * @memberof UnitsSummaryCreate
   */
  unitAccessibilityPriorityTypes?: IdDTO;
  /**
   *
   * @type {number}
   * @memberof UnitsSummaryCreate
   */
  totalCount?: number;
  /**
   *
   * @type {number}
   * @memberof UnitsSummaryCreate
   */
  totalAvailable?: number;
}
/**
 *
 * @export
 * @interface UpdatePassword
 */
export interface UpdatePassword {
  /**
   *
   * @type {string}
   * @memberof UpdatePassword
   */
  password: string;
  /**
   *
   * @type {string}
   * @memberof UpdatePassword
   */
  passwordConfirmation: string;
  /**
   *
   * @type {string}
   * @memberof UpdatePassword
   */
  token: string;
}
/**
 *
 * @export
 * @interface User
 */
export interface User {
  /**
   *
   * @type {string}
   * @memberof User
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof User
   */
  createdAt: string;
  /**
   *
   * @type {string}
   * @memberof User
   */
  updatedAt: string;
  /**
   *
   * @type {string}
   * @memberof User
   */
  passwordUpdatedAt: string;
  /**
   *
   * @type {number}
   * @memberof User
   */
  passwordValidForDays: number;
  /**
   *
   * @type {string}
   * @memberof User
   */
  confirmedAt?: string;
  /**
   *
   * @type {string}
   * @memberof User
   */
  email: string;
  /**
   *
   * @type {string}
   * @memberof User
   */
  firstName: string;
  /**
   *
   * @type {string}
   * @memberof User
   */
  middleName?: string;
  /**
   *
   * @type {string}
   * @memberof User
   */
  lastName: string;
  /**
   *
   * @type {string}
   * @memberof User
   */
  dob?: string;
  /**
   *
   * @type {string}
   * @memberof User
   */
  phoneNumber?: string;
  /**
   *
   * @type {Array<IdDTO>}
   * @memberof User
   */
  listings: Array<IdDTO> | null;
  /**
   *
   * @type {UserRole}
   * @memberof User
   */
  userRoles?: UserRole;
  /**
   *
   * @type {LanguagesEnum}
   * @memberof User
   */
  language?: LanguagesEnum;
  /**
   *
   * @type {Array<Jurisdiction>}
   * @memberof User
   */
  jurisdictions: Array<Jurisdiction>;
  /**
   *
   * @type {boolean}
   * @memberof User
   */
  mfaEnabled?: boolean;
  /**
   *
   * @type {string}
   * @memberof User
   */
  lastLoginAt?: string;
  /**
   *
   * @type {number}
   * @memberof User
   */
  failedLoginAttemptsCount?: number;
  /**
   *
   * @type {boolean}
   * @memberof User
   */
  phoneNumberVerified?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof User
   */
  agreedToTermsOfService: boolean;
  /**
   *
   * @type {string}
   * @memberof User
   */
  hitConfirmationURL?: string;
  /**
   *
   * @type {string}
   * @memberof User
   */
  activeAccessToken?: string;
  /**
   *
   * @type {string}
   * @memberof User
   */
  activeRefreshToken?: string;
}

/**
 *
 * @export
 * @interface UserCreate
 */
export interface UserCreate {
  /**
   *
   * @type {string}
   * @memberof UserCreate
   */
  firstName: string;
  /**
   *
   * @type {string}
   * @memberof UserCreate
   */
  middleName?: string;
  /**
   *
   * @type {string}
   * @memberof UserCreate
   */
  lastName: string;
  /**
   *
   * @type {string}
   * @memberof UserCreate
   */
  dob?: string;
  /**
   *
   * @type {string}
   * @memberof UserCreate
   */
  phoneNumber?: string;
  /**
   *
   * @type {Array<IdDTO>}
   * @memberof UserCreate
   */
  listings: Array<IdDTO> | null;
  /**
   *
   * @type {LanguagesEnum}
   * @memberof UserCreate
   */
  language?: LanguagesEnum;
  /**
   *
   * @type {boolean}
   * @memberof UserCreate
   */
  agreedToTermsOfService: boolean;
  /**
   *
   * @type {string}
   * @memberof UserCreate
   */
  newEmail?: string;
  /**
   *
   * @type {string}
   * @memberof UserCreate
   */
  appUrl?: string;
  /**
   *
   * @type {string}
   * @memberof UserCreate
   */
  password: string;
  /**
   *
   * @type {string}
   * @memberof UserCreate
   */
  passwordConfirmation: string;
  /**
   *
   * @type {string}
   * @memberof UserCreate
   */
  email: string;
  /**
   *
   * @type {string}
   * @memberof UserCreate
   */
  emailConfirmation?: string;
  /**
   *
   * @type {Array<IdDTO>}
   * @memberof UserCreate
   */
  jurisdictions?: Array<IdDTO>;
}

/**
 *
 * @export
 * @interface UserFilterParams
 */
export interface UserFilterParams {
  /**
   *
   * @type {boolean}
   * @memberof UserFilterParams
   */
  isPortalUser?: boolean;
}
/**
 *
 * @export
 * @interface UserInvite
 */
export interface UserInvite {
  /**
   *
   * @type {string}
   * @memberof UserInvite
   */
  firstName: string;
  /**
   *
   * @type {string}
   * @memberof UserInvite
   */
  middleName?: string;
  /**
   *
   * @type {string}
   * @memberof UserInvite
   */
  lastName: string;
  /**
   *
   * @type {string}
   * @memberof UserInvite
   */
  dob?: string;
  /**
   *
   * @type {string}
   * @memberof UserInvite
   */
  phoneNumber?: string;
  /**
   *
   * @type {Array<IdDTO>}
   * @memberof UserInvite
   */
  listings: Array<IdDTO> | null;
  /**
   *
   * @type {UserRole}
   * @memberof UserInvite
   */
  userRoles?: UserRole;
  /**
   *
   * @type {LanguagesEnum}
   * @memberof UserInvite
   */
  language?: LanguagesEnum;
  /**
   *
   * @type {string}
   * @memberof UserInvite
   */
  newEmail?: string;
  /**
   *
   * @type {string}
   * @memberof UserInvite
   */
  appUrl?: string;
  /**
   *
   * @type {string}
   * @memberof UserInvite
   */
  email: string;
  /**
   *
   * @type {Array<IdDTO>}
   * @memberof UserInvite
   */
  jurisdictions: Array<IdDTO>;
}

/**
 *
 * @export
 * @interface UserRole
 */
export interface UserRole {
  /**
   *
   * @type {boolean}
   * @memberof UserRole
   */
  isAdmin?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof UserRole
   */
  isJurisdictionalAdmin?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof UserRole
   */
  isLimitedJurisdictionalAdmin?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof UserRole
   */
  isPartner?: boolean;
}
/**
 *
 * @export
 * @interface UserUpdate
 */
export interface UserUpdate {
  /**
   *
   * @type {string}
   * @memberof UserUpdate
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof UserUpdate
   */
  firstName: string;
  /**
   *
   * @type {string}
   * @memberof UserUpdate
   */
  middleName?: string;
  /**
   *
   * @type {string}
   * @memberof UserUpdate
   */
  lastName: string;
  /**
   *
   * @type {string}
   * @memberof UserUpdate
   */
  dob?: string;
  /**
   *
   * @type {string}
   * @memberof UserUpdate
   */
  phoneNumber?: string;
  /**
   *
   * @type {Array<IdDTO>}
   * @memberof UserUpdate
   */
  listings: Array<IdDTO> | null;
  /**
   *
   * @type {UserRole}
   * @memberof UserUpdate
   */
  userRoles?: UserRole;
  /**
   *
   * @type {LanguagesEnum}
   * @memberof UserUpdate
   */
  language?: LanguagesEnum;
  /**
   *
   * @type {boolean}
   * @memberof UserUpdate
   */
  agreedToTermsOfService: boolean;
  /**
   *
   * @type {string}
   * @memberof UserUpdate
   */
  email?: string;
  /**
   *
   * @type {string}
   * @memberof UserUpdate
   */
  newEmail?: string;
  /**
   *
   * @type {string}
   * @memberof UserUpdate
   */
  password?: string;
  /**
   *
   * @type {string}
   * @memberof UserUpdate
   */
  currentPassword?: string;
  /**
   *
   * @type {string}
   * @memberof UserUpdate
   */
  appUrl?: string;
  /**
   *
   * @type {Array<IdDTO>}
   * @memberof UserUpdate
   */
  jurisdictions?: Array<IdDTO>;
}

/**
 *
 * @export
 * @enum {string}
 */

export const ValidationMethodEnum = {
  Radius: "radius",
  Map: "map",
  None: "none",
} as const;

export type ValidationMethodEnum =
  (typeof ValidationMethodEnum)[keyof typeof ValidationMethodEnum];

/**
 *
 * @export
 * @enum {string}
 */

export const YesNoEnum = {
  Yes: "yes",
  No: "no",
} as const;

export type YesNoEnum = (typeof YesNoEnum)[keyof typeof YesNoEnum];

/**
 * AmiChartsApi - axios parameter creator
 * @export
 */
export const AmiChartsApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     *
     * @summary Delete amiChart by id
     * @param {IdDTO} idDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    _delete: async (
      idDTO: IdDTO,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'idDTO' is not null or undefined
      assertParamExists("_delete", "idDTO", idDTO);
      const localVarPath = `/amiCharts`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        idDTO,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Create amiChart
     * @param {AmiChartCreate} amiChartCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    create: async (
      amiChartCreate: AmiChartCreate,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'amiChartCreate' is not null or undefined
      assertParamExists("create", "amiChartCreate", amiChartCreate);
      const localVarPath = `/amiCharts`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        amiChartCreate,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary List amiCharts
     * @param {string} [jurisdictionId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    list: async (
      jurisdictionId?: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/amiCharts`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (jurisdictionId !== undefined) {
        localVarQueryParameter["jurisdictionId"] = jurisdictionId;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get amiChart by id
     * @param {string} amiChartId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    retrieve: async (
      amiChartId: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'amiChartId' is not null or undefined
      assertParamExists("retrieve", "amiChartId", amiChartId);
      const localVarPath = `/amiCharts/{amiChartId}`.replace(
        `{${"amiChartId"}}`,
        encodeURIComponent(String(amiChartId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Update amiChart
     * @param {AmiChartUpdate} amiChartUpdate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    update: async (
      amiChartUpdate: AmiChartUpdate,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'amiChartUpdate' is not null or undefined
      assertParamExists("update", "amiChartUpdate", amiChartUpdate);
      const localVarPath = `/amiCharts/{amiChartId}`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        amiChartUpdate,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * AmiChartsApi - functional programming interface
 * @export
 */
export const AmiChartsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    AmiChartsApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary Delete amiChart by id
     * @param {IdDTO} idDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async _delete(
      idDTO: IdDTO,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessDTO>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator._delete(
        idDTO,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["AmiChartsApi._delete"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Create amiChart
     * @param {AmiChartCreate} amiChartCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async create(
      amiChartCreate: AmiChartCreate,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<AmiChart>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.create(
        amiChartCreate,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["AmiChartsApi.create"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary List amiCharts
     * @param {string} [jurisdictionId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async list(
      jurisdictionId?: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<Array<AmiChart>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.list(
        jurisdictionId,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["AmiChartsApi.list"]?.[localVarOperationServerIndex]
          ?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Get amiChart by id
     * @param {string} amiChartId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async retrieve(
      amiChartId: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<AmiChart>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.retrieve(
        amiChartId,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["AmiChartsApi.retrieve"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Update amiChart
     * @param {AmiChartUpdate} amiChartUpdate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async update(
      amiChartUpdate: AmiChartUpdate,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<AmiChart>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.update(
        amiChartUpdate,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["AmiChartsApi.update"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * AmiChartsApi - factory interface
 * @export
 */
export const AmiChartsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = AmiChartsApiFp(configuration);
  return {
    /**
     *
     * @summary Delete amiChart by id
     * @param {IdDTO} idDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    _delete(idDTO: IdDTO, options?: any): AxiosPromise<SuccessDTO> {
      return localVarFp
        ._delete(idDTO, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Create amiChart
     * @param {AmiChartCreate} amiChartCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    create(
      amiChartCreate: AmiChartCreate,
      options?: any,
    ): AxiosPromise<AmiChart> {
      return localVarFp
        .create(amiChartCreate, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary List amiCharts
     * @param {string} [jurisdictionId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    list(
      jurisdictionId?: string,
      options?: any,
    ): AxiosPromise<Array<AmiChart>> {
      return localVarFp
        .list(jurisdictionId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get amiChart by id
     * @param {string} amiChartId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    retrieve(amiChartId: string, options?: any): AxiosPromise<AmiChart> {
      return localVarFp
        .retrieve(amiChartId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Update amiChart
     * @param {AmiChartUpdate} amiChartUpdate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    update(
      amiChartUpdate: AmiChartUpdate,
      options?: any,
    ): AxiosPromise<AmiChart> {
      return localVarFp
        .update(amiChartUpdate, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * AmiChartsApi - object-oriented interface
 * @export
 * @class AmiChartsApi
 * @extends {BaseAPI}
 */
export class AmiChartsApi extends BaseAPI {
  /**
   *
   * @summary Delete amiChart by id
   * @param {IdDTO} idDTO
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AmiChartsApi
   */
  public _delete(idDTO: IdDTO, options?: RawAxiosRequestConfig) {
    return AmiChartsApiFp(this.configuration)
      ._delete(idDTO, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Create amiChart
   * @param {AmiChartCreate} amiChartCreate
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AmiChartsApi
   */
  public create(
    amiChartCreate: AmiChartCreate,
    options?: RawAxiosRequestConfig,
  ) {
    return AmiChartsApiFp(this.configuration)
      .create(amiChartCreate, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary List amiCharts
   * @param {string} [jurisdictionId]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AmiChartsApi
   */
  public list(jurisdictionId?: string, options?: RawAxiosRequestConfig) {
    return AmiChartsApiFp(this.configuration)
      .list(jurisdictionId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get amiChart by id
   * @param {string} amiChartId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AmiChartsApi
   */
  public retrieve(amiChartId: string, options?: RawAxiosRequestConfig) {
    return AmiChartsApiFp(this.configuration)
      .retrieve(amiChartId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Update amiChart
   * @param {AmiChartUpdate} amiChartUpdate
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AmiChartsApi
   */
  public update(
    amiChartUpdate: AmiChartUpdate,
    options?: RawAxiosRequestConfig,
  ) {
    return AmiChartsApiFp(this.configuration)
      .update(amiChartUpdate, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * ApplicationFlaggedSetsApi - axios parameter creator
 * @export
 */
export const ApplicationFlaggedSetsApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     *
     * @summary List application flagged sets
     * @param {string} listingId
     * @param {number} [page]
     * @param {number} [limit]
     * @param {AfsView} [view]
     * @param {string} [search]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    list: async (
      listingId: string,
      page?: number,
      limit?: number,
      view?: AfsView,
      search?: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'listingId' is not null or undefined
      assertParamExists("list", "listingId", listingId);
      const localVarPath = `/applicationFlaggedSets`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (page !== undefined) {
        localVarQueryParameter["page"] = page;
      }

      if (limit !== undefined) {
        localVarQueryParameter["limit"] = limit;
      }

      if (listingId !== undefined) {
        localVarQueryParameter["listingId"] = listingId;
      }

      if (view !== undefined) {
        localVarQueryParameter["view"] = view;
      }

      if (search !== undefined) {
        localVarQueryParameter["search"] = search;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Meta information for application flagged sets
     * @param {string} listingId
     * @param {number} [page]
     * @param {number} [limit]
     * @param {AfsView} [view]
     * @param {string} [search]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    meta: async (
      listingId: string,
      page?: number,
      limit?: number,
      view?: AfsView,
      search?: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'listingId' is not null or undefined
      assertParamExists("meta", "listingId", listingId);
      const localVarPath = `/applicationFlaggedSets/meta`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (page !== undefined) {
        localVarQueryParameter["page"] = page;
      }

      if (limit !== undefined) {
        localVarQueryParameter["limit"] = limit;
      }

      if (listingId !== undefined) {
        localVarQueryParameter["listingId"] = listingId;
      }

      if (view !== undefined) {
        localVarQueryParameter["view"] = view;
      }

      if (search !== undefined) {
        localVarQueryParameter["search"] = search;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Trigger the duplicate check process
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    process: async (
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/applicationFlaggedSets/process`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Trigger the duplicate check process
     * @param {string} [listingId]
     * @param {boolean} [force]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    processDuplicates: async (
      listingId?: string,
      force?: boolean,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/applicationFlaggedSets/process_duplicates`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (listingId !== undefined) {
        localVarQueryParameter["listingId"] = listingId;
      }

      if (force !== undefined) {
        localVarQueryParameter["force"] = force;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Reset flagged set confirmation alert
     * @param {IdDTO} idDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    resetConfirmationAlert: async (
      idDTO: IdDTO,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'idDTO' is not null or undefined
      assertParamExists("resetConfirmationAlert", "idDTO", idDTO);
      const localVarPath = `/applicationFlaggedSets/{afsId}`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        idDTO,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Resolve application flagged set
     * @param {AfsResolve} afsResolve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    resolve: async (
      afsResolve: AfsResolve,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'afsResolve' is not null or undefined
      assertParamExists("resolve", "afsResolve", afsResolve);
      const localVarPath = `/applicationFlaggedSets/resolve`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        afsResolve,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Retrieve application flagged set by id
     * @param {string} afsId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    retrieve: async (
      afsId: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'afsId' is not null or undefined
      assertParamExists("retrieve", "afsId", afsId);
      const localVarPath = `/applicationFlaggedSets/{afsId}`.replace(
        `{${"afsId"}}`,
        encodeURIComponent(String(afsId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * ApplicationFlaggedSetsApi - functional programming interface
 * @export
 */
export const ApplicationFlaggedSetsApiFp = function (
  configuration?: Configuration,
) {
  const localVarAxiosParamCreator =
    ApplicationFlaggedSetsApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary List application flagged sets
     * @param {string} listingId
     * @param {number} [page]
     * @param {number} [limit]
     * @param {AfsView} [view]
     * @param {string} [search]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async list(
      listingId: string,
      page?: number,
      limit?: number,
      view?: AfsView,
      search?: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<PaginatedAfsDto>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.list(
        listingId,
        page,
        limit,
        view,
        search,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ApplicationFlaggedSetsApi.list"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Meta information for application flagged sets
     * @param {string} listingId
     * @param {number} [page]
     * @param {number} [limit]
     * @param {AfsView} [view]
     * @param {string} [search]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async meta(
      listingId: string,
      page?: number,
      limit?: number,
      view?: AfsView,
      search?: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<AfsMeta>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.meta(
        listingId,
        page,
        limit,
        view,
        search,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ApplicationFlaggedSetsApi.meta"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Trigger the duplicate check process
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async process(
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessDTO>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.process(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ApplicationFlaggedSetsApi.process"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Trigger the duplicate check process
     * @param {string} [listingId]
     * @param {boolean} [force]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async processDuplicates(
      listingId?: string,
      force?: boolean,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessDTO>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.processDuplicates(
          listingId,
          force,
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ApplicationFlaggedSetsApi.processDuplicates"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Reset flagged set confirmation alert
     * @param {IdDTO} idDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async resetConfirmationAlert(
      idDTO: IdDTO,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessDTO>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.resetConfirmationAlert(idDTO, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap[
          "ApplicationFlaggedSetsApi.resetConfirmationAlert"
        ]?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Resolve application flagged set
     * @param {AfsResolve} afsResolve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async resolve(
      afsResolve: AfsResolve,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<ApplicationFlaggedSet>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.resolve(
        afsResolve,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ApplicationFlaggedSetsApi.resolve"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Retrieve application flagged set by id
     * @param {string} afsId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async retrieve(
      afsId: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<ApplicationFlaggedSet>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.retrieve(
        afsId,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ApplicationFlaggedSetsApi.retrieve"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * ApplicationFlaggedSetsApi - factory interface
 * @export
 */
export const ApplicationFlaggedSetsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = ApplicationFlaggedSetsApiFp(configuration);
  return {
    /**
     *
     * @summary List application flagged sets
     * @param {string} listingId
     * @param {number} [page]
     * @param {number} [limit]
     * @param {AfsView} [view]
     * @param {string} [search]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    list(
      listingId: string,
      page?: number,
      limit?: number,
      view?: AfsView,
      search?: string,
      options?: any,
    ): AxiosPromise<PaginatedAfsDto> {
      return localVarFp
        .list(listingId, page, limit, view, search, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Meta information for application flagged sets
     * @param {string} listingId
     * @param {number} [page]
     * @param {number} [limit]
     * @param {AfsView} [view]
     * @param {string} [search]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    meta(
      listingId: string,
      page?: number,
      limit?: number,
      view?: AfsView,
      search?: string,
      options?: any,
    ): AxiosPromise<AfsMeta> {
      return localVarFp
        .meta(listingId, page, limit, view, search, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Trigger the duplicate check process
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    process(options?: any): AxiosPromise<SuccessDTO> {
      return localVarFp
        .process(options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Trigger the duplicate check process
     * @param {string} [listingId]
     * @param {boolean} [force]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    processDuplicates(
      listingId?: string,
      force?: boolean,
      options?: any,
    ): AxiosPromise<SuccessDTO> {
      return localVarFp
        .processDuplicates(listingId, force, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Reset flagged set confirmation alert
     * @param {IdDTO} idDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    resetConfirmationAlert(
      idDTO: IdDTO,
      options?: any,
    ): AxiosPromise<SuccessDTO> {
      return localVarFp
        .resetConfirmationAlert(idDTO, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Resolve application flagged set
     * @param {AfsResolve} afsResolve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    resolve(
      afsResolve: AfsResolve,
      options?: any,
    ): AxiosPromise<ApplicationFlaggedSet> {
      return localVarFp
        .resolve(afsResolve, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Retrieve application flagged set by id
     * @param {string} afsId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    retrieve(
      afsId: string,
      options?: any,
    ): AxiosPromise<ApplicationFlaggedSet> {
      return localVarFp
        .retrieve(afsId, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * ApplicationFlaggedSetsApi - object-oriented interface
 * @export
 * @class ApplicationFlaggedSetsApi
 * @extends {BaseAPI}
 */
export class ApplicationFlaggedSetsApi extends BaseAPI {
  /**
   *
   * @summary List application flagged sets
   * @param {string} listingId
   * @param {number} [page]
   * @param {number} [limit]
   * @param {AfsView} [view]
   * @param {string} [search]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ApplicationFlaggedSetsApi
   */
  public list(
    listingId: string,
    page?: number,
    limit?: number,
    view?: AfsView,
    search?: string,
    options?: RawAxiosRequestConfig,
  ) {
    return ApplicationFlaggedSetsApiFp(this.configuration)
      .list(listingId, page, limit, view, search, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Meta information for application flagged sets
   * @param {string} listingId
   * @param {number} [page]
   * @param {number} [limit]
   * @param {AfsView} [view]
   * @param {string} [search]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ApplicationFlaggedSetsApi
   */
  public meta(
    listingId: string,
    page?: number,
    limit?: number,
    view?: AfsView,
    search?: string,
    options?: RawAxiosRequestConfig,
  ) {
    return ApplicationFlaggedSetsApiFp(this.configuration)
      .meta(listingId, page, limit, view, search, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Trigger the duplicate check process
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ApplicationFlaggedSetsApi
   */
  public process(options?: RawAxiosRequestConfig) {
    return ApplicationFlaggedSetsApiFp(this.configuration)
      .process(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Trigger the duplicate check process
   * @param {string} [listingId]
   * @param {boolean} [force]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ApplicationFlaggedSetsApi
   */
  public processDuplicates(
    listingId?: string,
    force?: boolean,
    options?: RawAxiosRequestConfig,
  ) {
    return ApplicationFlaggedSetsApiFp(this.configuration)
      .processDuplicates(listingId, force, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Reset flagged set confirmation alert
   * @param {IdDTO} idDTO
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ApplicationFlaggedSetsApi
   */
  public resetConfirmationAlert(idDTO: IdDTO, options?: RawAxiosRequestConfig) {
    return ApplicationFlaggedSetsApiFp(this.configuration)
      .resetConfirmationAlert(idDTO, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Resolve application flagged set
   * @param {AfsResolve} afsResolve
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ApplicationFlaggedSetsApi
   */
  public resolve(afsResolve: AfsResolve, options?: RawAxiosRequestConfig) {
    return ApplicationFlaggedSetsApiFp(this.configuration)
      .resolve(afsResolve, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Retrieve application flagged set by id
   * @param {string} afsId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ApplicationFlaggedSetsApi
   */
  public retrieve(afsId: string, options?: RawAxiosRequestConfig) {
    return ApplicationFlaggedSetsApiFp(this.configuration)
      .retrieve(afsId, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * ApplicationsApi - axios parameter creator
 * @export
 */
export const ApplicationsApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     *
     * @summary Delete application by id
     * @param {IdDTO} idDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    _delete: async (
      idDTO: IdDTO,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'idDTO' is not null or undefined
      assertParamExists("_delete", "idDTO", idDTO);
      const localVarPath = `/applications`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        idDTO,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Create application (used by partners to hand create an application)
     * @param {ApplicationCreate} applicationCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    create: async (
      applicationCreate: ApplicationCreate,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'applicationCreate' is not null or undefined
      assertParamExists("create", "applicationCreate", applicationCreate);
      const localVarPath = `/applications`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        applicationCreate,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get a paginated set of applications
     * @param {number} [page]
     * @param {number} [limit]
     * @param {string} [listingId]
     * @param {string} [search]
     * @param {string} [userId]
     * @param {ApplicationOrderByKeys} [orderBy]
     * @param {OrderByEnum} [order]
     * @param {boolean} [markedAsDuplicate]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    list: async (
      page?: number,
      limit?: number,
      listingId?: string,
      search?: string,
      userId?: string,
      orderBy?: ApplicationOrderByKeys,
      order?: OrderByEnum,
      markedAsDuplicate?: boolean,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/applications`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (page !== undefined) {
        localVarQueryParameter["page"] = page;
      }

      if (limit !== undefined) {
        localVarQueryParameter["limit"] = limit;
      }

      if (listingId !== undefined) {
        localVarQueryParameter["listingId"] = listingId;
      }

      if (search !== undefined) {
        localVarQueryParameter["search"] = search;
      }

      if (userId !== undefined) {
        localVarQueryParameter["userId"] = userId;
      }

      if (orderBy !== undefined) {
        localVarQueryParameter["orderBy"] = orderBy;
      }

      if (order !== undefined) {
        localVarQueryParameter["order"] = order;
      }

      if (markedAsDuplicate !== undefined) {
        localVarQueryParameter["markedAsDuplicate"] = markedAsDuplicate;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get applications as csv
     * @param {string} id
     * @param {boolean} [includeDemographics]
     * @param {string} [timeZone]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listAsCsv: async (
      id: string,
      includeDemographics?: boolean,
      timeZone?: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("listAsCsv", "id", id);
      const localVarPath = `/applications/csv`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (id !== undefined) {
        localVarQueryParameter["id"] = id;
      }

      if (includeDemographics !== undefined) {
        localVarQueryParameter["includeDemographics"] = includeDemographics;
      }

      if (timeZone !== undefined) {
        localVarQueryParameter["timeZone"] = timeZone;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get applications as spreadsheet
     * @param {string} id
     * @param {boolean} [includeDemographics]
     * @param {string} [timeZone]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listAsSpreadsheet: async (
      id: string,
      includeDemographics?: boolean,
      timeZone?: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("listAsSpreadsheet", "id", id);
      const localVarPath = `/applications/spreadsheet`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (id !== undefined) {
        localVarQueryParameter["id"] = id;
      }

      if (includeDemographics !== undefined) {
        localVarQueryParameter["includeDemographics"] = includeDemographics;
      }

      if (timeZone !== undefined) {
        localVarQueryParameter["timeZone"] = timeZone;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get the most recent application submitted by the user
     * @param {string} userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    mostRecentlyCreated: async (
      userId: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'userId' is not null or undefined
      assertParamExists("mostRecentlyCreated", "userId", userId);
      const localVarPath = `/applications/mostRecentlyCreated`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (userId !== undefined) {
        localVarQueryParameter["userId"] = userId;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get public applications info
     * @param {string} userId
     * @param {ApplicationsFilterEnum} [filterType]
     * @param {boolean} [includeLotteryApps]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    publicAppsView: async (
      userId: string,
      filterType?: ApplicationsFilterEnum,
      includeLotteryApps?: boolean,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'userId' is not null or undefined
      assertParamExists("publicAppsView", "userId", userId);
      const localVarPath = `/applications/publicAppsView`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (userId !== undefined) {
        localVarQueryParameter["userId"] = userId;
      }

      if (filterType !== undefined) {
        localVarQueryParameter["filterType"] = filterType;
      }

      if (includeLotteryApps !== undefined) {
        localVarQueryParameter["includeLotteryApps"] = includeLotteryApps;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get application by id
     * @param {string} applicationId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    retrieve: async (
      applicationId: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'applicationId' is not null or undefined
      assertParamExists("retrieve", "applicationId", applicationId);
      const localVarPath = `/applications/{applicationId}`.replace(
        `{${"applicationId"}}`,
        encodeURIComponent(String(applicationId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Verify application can be saved
     * @param {ApplicationCreate} applicationCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    submissionValidation: async (
      applicationCreate: ApplicationCreate,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'applicationCreate' is not null or undefined
      assertParamExists(
        "submissionValidation",
        "applicationCreate",
        applicationCreate,
      );
      const localVarPath = `/applications/verify`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        applicationCreate,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Submit application (used by applicants applying to a listing)
     * @param {ApplicationCreate} applicationCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    submit: async (
      applicationCreate: ApplicationCreate,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'applicationCreate' is not null or undefined
      assertParamExists("submit", "applicationCreate", applicationCreate);
      const localVarPath = `/applications/submit`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        applicationCreate,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Update application by id
     * @param {string} id
     * @param {ApplicationUpdate} applicationUpdate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    update: async (
      id: string,
      applicationUpdate: ApplicationUpdate,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("update", "id", id);
      // verify required parameter 'applicationUpdate' is not null or undefined
      assertParamExists("update", "applicationUpdate", applicationUpdate);
      const localVarPath = `/applications/{applicationId}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        applicationUpdate,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * ApplicationsApi - functional programming interface
 * @export
 */
export const ApplicationsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    ApplicationsApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary Delete application by id
     * @param {IdDTO} idDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async _delete(
      idDTO: IdDTO,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessDTO>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator._delete(
        idDTO,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ApplicationsApi._delete"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Create application (used by partners to hand create an application)
     * @param {ApplicationCreate} applicationCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async create(
      applicationCreate: ApplicationCreate,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Application>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.create(
        applicationCreate,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ApplicationsApi.create"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Get a paginated set of applications
     * @param {number} [page]
     * @param {number} [limit]
     * @param {string} [listingId]
     * @param {string} [search]
     * @param {string} [userId]
     * @param {ApplicationOrderByKeys} [orderBy]
     * @param {OrderByEnum} [order]
     * @param {boolean} [markedAsDuplicate]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async list(
      page?: number,
      limit?: number,
      listingId?: string,
      search?: string,
      userId?: string,
      orderBy?: ApplicationOrderByKeys,
      order?: OrderByEnum,
      markedAsDuplicate?: boolean,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<PaginatedApplicationDto>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.list(
        page,
        limit,
        listingId,
        search,
        userId,
        orderBy,
        order,
        markedAsDuplicate,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ApplicationsApi.list"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Get applications as csv
     * @param {string} id
     * @param {boolean} [includeDemographics]
     * @param {string} [timeZone]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listAsCsv(
      id: string,
      includeDemographics?: boolean,
      timeZone?: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listAsCsv(
        id,
        includeDemographics,
        timeZone,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ApplicationsApi.listAsCsv"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Get applications as spreadsheet
     * @param {string} id
     * @param {boolean} [includeDemographics]
     * @param {string} [timeZone]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listAsSpreadsheet(
      id: string,
      includeDemographics?: boolean,
      timeZone?: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.listAsSpreadsheet(
          id,
          includeDemographics,
          timeZone,
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ApplicationsApi.listAsSpreadsheet"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Get the most recent application submitted by the user
     * @param {string} userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async mostRecentlyCreated(
      userId: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Application>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.mostRecentlyCreated(userId, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ApplicationsApi.mostRecentlyCreated"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Get public applications info
     * @param {string} userId
     * @param {ApplicationsFilterEnum} [filterType]
     * @param {boolean} [includeLotteryApps]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async publicAppsView(
      userId: string,
      filterType?: ApplicationsFilterEnum,
      includeLotteryApps?: boolean,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<PublicAppsViewResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.publicAppsView(
        userId,
        filterType,
        includeLotteryApps,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ApplicationsApi.publicAppsView"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Get application by id
     * @param {string} applicationId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async retrieve(
      applicationId: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Application>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.retrieve(
        applicationId,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ApplicationsApi.retrieve"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Verify application can be saved
     * @param {ApplicationCreate} applicationCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async submissionValidation(
      applicationCreate: ApplicationCreate,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessDTO>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.submissionValidation(
          applicationCreate,
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ApplicationsApi.submissionValidation"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Submit application (used by applicants applying to a listing)
     * @param {ApplicationCreate} applicationCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async submit(
      applicationCreate: ApplicationCreate,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Application>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.submit(
        applicationCreate,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ApplicationsApi.submit"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Update application by id
     * @param {string} id
     * @param {ApplicationUpdate} applicationUpdate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async update(
      id: string,
      applicationUpdate: ApplicationUpdate,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Application>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.update(
        id,
        applicationUpdate,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ApplicationsApi.update"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * ApplicationsApi - factory interface
 * @export
 */
export const ApplicationsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = ApplicationsApiFp(configuration);
  return {
    /**
     *
     * @summary Delete application by id
     * @param {IdDTO} idDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    _delete(idDTO: IdDTO, options?: any): AxiosPromise<SuccessDTO> {
      return localVarFp
        ._delete(idDTO, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Create application (used by partners to hand create an application)
     * @param {ApplicationCreate} applicationCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    create(
      applicationCreate: ApplicationCreate,
      options?: any,
    ): AxiosPromise<Application> {
      return localVarFp
        .create(applicationCreate, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get a paginated set of applications
     * @param {number} [page]
     * @param {number} [limit]
     * @param {string} [listingId]
     * @param {string} [search]
     * @param {string} [userId]
     * @param {ApplicationOrderByKeys} [orderBy]
     * @param {OrderByEnum} [order]
     * @param {boolean} [markedAsDuplicate]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    list(
      page?: number,
      limit?: number,
      listingId?: string,
      search?: string,
      userId?: string,
      orderBy?: ApplicationOrderByKeys,
      order?: OrderByEnum,
      markedAsDuplicate?: boolean,
      options?: any,
    ): AxiosPromise<PaginatedApplicationDto> {
      return localVarFp
        .list(
          page,
          limit,
          listingId,
          search,
          userId,
          orderBy,
          order,
          markedAsDuplicate,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get applications as csv
     * @param {string} id
     * @param {boolean} [includeDemographics]
     * @param {string} [timeZone]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listAsCsv(
      id: string,
      includeDemographics?: boolean,
      timeZone?: string,
      options?: any,
    ): AxiosPromise<void> {
      return localVarFp
        .listAsCsv(id, includeDemographics, timeZone, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get applications as spreadsheet
     * @param {string} id
     * @param {boolean} [includeDemographics]
     * @param {string} [timeZone]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listAsSpreadsheet(
      id: string,
      includeDemographics?: boolean,
      timeZone?: string,
      options?: any,
    ): AxiosPromise<void> {
      return localVarFp
        .listAsSpreadsheet(id, includeDemographics, timeZone, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get the most recent application submitted by the user
     * @param {string} userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    mostRecentlyCreated(
      userId: string,
      options?: any,
    ): AxiosPromise<Application> {
      return localVarFp
        .mostRecentlyCreated(userId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get public applications info
     * @param {string} userId
     * @param {ApplicationsFilterEnum} [filterType]
     * @param {boolean} [includeLotteryApps]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    publicAppsView(
      userId: string,
      filterType?: ApplicationsFilterEnum,
      includeLotteryApps?: boolean,
      options?: any,
    ): AxiosPromise<PublicAppsViewResponse> {
      return localVarFp
        .publicAppsView(userId, filterType, includeLotteryApps, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get application by id
     * @param {string} applicationId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    retrieve(applicationId: string, options?: any): AxiosPromise<Application> {
      return localVarFp
        .retrieve(applicationId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Verify application can be saved
     * @param {ApplicationCreate} applicationCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    submissionValidation(
      applicationCreate: ApplicationCreate,
      options?: any,
    ): AxiosPromise<SuccessDTO> {
      return localVarFp
        .submissionValidation(applicationCreate, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Submit application (used by applicants applying to a listing)
     * @param {ApplicationCreate} applicationCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    submit(
      applicationCreate: ApplicationCreate,
      options?: any,
    ): AxiosPromise<Application> {
      return localVarFp
        .submit(applicationCreate, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Update application by id
     * @param {string} id
     * @param {ApplicationUpdate} applicationUpdate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    update(
      id: string,
      applicationUpdate: ApplicationUpdate,
      options?: any,
    ): AxiosPromise<Application> {
      return localVarFp
        .update(id, applicationUpdate, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * ApplicationsApi - object-oriented interface
 * @export
 * @class ApplicationsApi
 * @extends {BaseAPI}
 */
export class ApplicationsApi extends BaseAPI {
  /**
   *
   * @summary Delete application by id
   * @param {IdDTO} idDTO
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ApplicationsApi
   */
  public _delete(idDTO: IdDTO, options?: RawAxiosRequestConfig) {
    return ApplicationsApiFp(this.configuration)
      ._delete(idDTO, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Create application (used by partners to hand create an application)
   * @param {ApplicationCreate} applicationCreate
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ApplicationsApi
   */
  public create(
    applicationCreate: ApplicationCreate,
    options?: RawAxiosRequestConfig,
  ) {
    return ApplicationsApiFp(this.configuration)
      .create(applicationCreate, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get a paginated set of applications
   * @param {number} [page]
   * @param {number} [limit]
   * @param {string} [listingId]
   * @param {string} [search]
   * @param {string} [userId]
   * @param {ApplicationOrderByKeys} [orderBy]
   * @param {OrderByEnum} [order]
   * @param {boolean} [markedAsDuplicate]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ApplicationsApi
   */
  public list(
    page?: number,
    limit?: number,
    listingId?: string,
    search?: string,
    userId?: string,
    orderBy?: ApplicationOrderByKeys,
    order?: OrderByEnum,
    markedAsDuplicate?: boolean,
    options?: RawAxiosRequestConfig,
  ) {
    return ApplicationsApiFp(this.configuration)
      .list(
        page,
        limit,
        listingId,
        search,
        userId,
        orderBy,
        order,
        markedAsDuplicate,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get applications as csv
   * @param {string} id
   * @param {boolean} [includeDemographics]
   * @param {string} [timeZone]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ApplicationsApi
   */
  public listAsCsv(
    id: string,
    includeDemographics?: boolean,
    timeZone?: string,
    options?: RawAxiosRequestConfig,
  ) {
    return ApplicationsApiFp(this.configuration)
      .listAsCsv(id, includeDemographics, timeZone, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get applications as spreadsheet
   * @param {string} id
   * @param {boolean} [includeDemographics]
   * @param {string} [timeZone]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ApplicationsApi
   */
  public listAsSpreadsheet(
    id: string,
    includeDemographics?: boolean,
    timeZone?: string,
    options?: RawAxiosRequestConfig,
  ) {
    return ApplicationsApiFp(this.configuration)
      .listAsSpreadsheet(id, includeDemographics, timeZone, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get the most recent application submitted by the user
   * @param {string} userId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ApplicationsApi
   */
  public mostRecentlyCreated(userId: string, options?: RawAxiosRequestConfig) {
    return ApplicationsApiFp(this.configuration)
      .mostRecentlyCreated(userId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get public applications info
   * @param {string} userId
   * @param {ApplicationsFilterEnum} [filterType]
   * @param {boolean} [includeLotteryApps]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ApplicationsApi
   */
  public publicAppsView(
    userId: string,
    filterType?: ApplicationsFilterEnum,
    includeLotteryApps?: boolean,
    options?: RawAxiosRequestConfig,
  ) {
    return ApplicationsApiFp(this.configuration)
      .publicAppsView(userId, filterType, includeLotteryApps, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get application by id
   * @param {string} applicationId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ApplicationsApi
   */
  public retrieve(applicationId: string, options?: RawAxiosRequestConfig) {
    return ApplicationsApiFp(this.configuration)
      .retrieve(applicationId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Verify application can be saved
   * @param {ApplicationCreate} applicationCreate
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ApplicationsApi
   */
  public submissionValidation(
    applicationCreate: ApplicationCreate,
    options?: RawAxiosRequestConfig,
  ) {
    return ApplicationsApiFp(this.configuration)
      .submissionValidation(applicationCreate, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Submit application (used by applicants applying to a listing)
   * @param {ApplicationCreate} applicationCreate
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ApplicationsApi
   */
  public submit(
    applicationCreate: ApplicationCreate,
    options?: RawAxiosRequestConfig,
  ) {
    return ApplicationsApiFp(this.configuration)
      .submit(applicationCreate, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Update application by id
   * @param {string} id
   * @param {ApplicationUpdate} applicationUpdate
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ApplicationsApi
   */
  public update(
    id: string,
    applicationUpdate: ApplicationUpdate,
    options?: RawAxiosRequestConfig,
  ) {
    return ApplicationsApiFp(this.configuration)
      .update(id, applicationUpdate, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * AssetApi - axios parameter creator
 * @export
 */
export const AssetApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     *
     * @summary Create asset
     * @param {AssetCreate} assetCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    create: async (
      assetCreate: AssetCreate,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'assetCreate' is not null or undefined
      assertParamExists("create", "assetCreate", assetCreate);
      const localVarPath = `/asset`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        assetCreate,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Create presigned upload metadata
     * @param {CreatePresignedUploadMetadata} createPresignedUploadMetadata
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createPresignedUploadMetadata: async (
      createPresignedUploadMetadata: CreatePresignedUploadMetadata,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'createPresignedUploadMetadata' is not null or undefined
      assertParamExists(
        "createPresignedUploadMetadata",
        "createPresignedUploadMetadata",
        createPresignedUploadMetadata,
      );
      const localVarPath = `/asset/presigned-upload-metadata`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        createPresignedUploadMetadata,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary List assets
     * @param {number} [page]
     * @param {number} [limit]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    list: async (
      page?: number,
      limit?: number,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/asset`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (page !== undefined) {
        localVarQueryParameter["page"] = page;
      }

      if (limit !== undefined) {
        localVarQueryParameter["limit"] = limit;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get asset by id
     * @param {string} assetId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    retrieve: async (
      assetId: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'assetId' is not null or undefined
      assertParamExists("retrieve", "assetId", assetId);
      const localVarPath = `/asset/{assetId}`.replace(
        `{${"assetId"}}`,
        encodeURIComponent(String(assetId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Upload asset
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    upload: async (
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/asset/upload`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * AssetApi - functional programming interface
 * @export
 */
export const AssetApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = AssetApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary Create asset
     * @param {AssetCreate} assetCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async create(
      assetCreate: AssetCreate,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.create(
        assetCreate,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["AssetApi.create"]?.[localVarOperationServerIndex]
          ?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Create presigned upload metadata
     * @param {CreatePresignedUploadMetadata} createPresignedUploadMetadata
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createPresignedUploadMetadata(
      createPresignedUploadMetadata: CreatePresignedUploadMetadata,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.createPresignedUploadMetadata(
          createPresignedUploadMetadata,
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["AssetApi.createPresignedUploadMetadata"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary List assets
     * @param {number} [page]
     * @param {number} [limit]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async list(
      page?: number,
      limit?: number,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.list(
        page,
        limit,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["AssetApi.list"]?.[localVarOperationServerIndex]
          ?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Get asset by id
     * @param {string} assetId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async retrieve(
      assetId: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.retrieve(
        assetId,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["AssetApi.retrieve"]?.[localVarOperationServerIndex]
          ?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Upload asset
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async upload(
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.upload(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["AssetApi.upload"]?.[localVarOperationServerIndex]
          ?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * AssetApi - factory interface
 * @export
 */
export const AssetApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = AssetApiFp(configuration);
  return {
    /**
     *
     * @summary Create asset
     * @param {AssetCreate} assetCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    create(assetCreate: AssetCreate, options?: any): AxiosPromise<void> {
      return localVarFp
        .create(assetCreate, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Create presigned upload metadata
     * @param {CreatePresignedUploadMetadata} createPresignedUploadMetadata
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createPresignedUploadMetadata(
      createPresignedUploadMetadata: CreatePresignedUploadMetadata,
      options?: any,
    ): AxiosPromise<void> {
      return localVarFp
        .createPresignedUploadMetadata(createPresignedUploadMetadata, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary List assets
     * @param {number} [page]
     * @param {number} [limit]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    list(page?: number, limit?: number, options?: any): AxiosPromise<void> {
      return localVarFp
        .list(page, limit, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get asset by id
     * @param {string} assetId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    retrieve(assetId: string, options?: any): AxiosPromise<void> {
      return localVarFp
        .retrieve(assetId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Upload asset
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    upload(options?: any): AxiosPromise<void> {
      return localVarFp
        .upload(options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * AssetApi - object-oriented interface
 * @export
 * @class AssetApi
 * @extends {BaseAPI}
 */
export class AssetApi extends BaseAPI {
  /**
   *
   * @summary Create asset
   * @param {AssetCreate} assetCreate
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AssetApi
   */
  public create(assetCreate: AssetCreate, options?: RawAxiosRequestConfig) {
    return AssetApiFp(this.configuration)
      .create(assetCreate, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Create presigned upload metadata
   * @param {CreatePresignedUploadMetadata} createPresignedUploadMetadata
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AssetApi
   */
  public createPresignedUploadMetadata(
    createPresignedUploadMetadata: CreatePresignedUploadMetadata,
    options?: RawAxiosRequestConfig,
  ) {
    return AssetApiFp(this.configuration)
      .createPresignedUploadMetadata(createPresignedUploadMetadata, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary List assets
   * @param {number} [page]
   * @param {number} [limit]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AssetApi
   */
  public list(page?: number, limit?: number, options?: RawAxiosRequestConfig) {
    return AssetApiFp(this.configuration)
      .list(page, limit, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get asset by id
   * @param {string} assetId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AssetApi
   */
  public retrieve(assetId: string, options?: RawAxiosRequestConfig) {
    return AssetApiFp(this.configuration)
      .retrieve(assetId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Upload asset
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AssetApi
   */
  public upload(options?: RawAxiosRequestConfig) {
    return AssetApiFp(this.configuration)
      .upload(options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * AuthApi - axios parameter creator
 * @export
 */
export const AuthApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     *
     * @summary Confirm email
     * @param {Confirm} confirm
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    confirm: async (
      confirm: Confirm,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'confirm' is not null or undefined
      assertParamExists("confirm", "confirm", confirm);
      const localVarPath = `/auth/confirm`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        confirm,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Login
     * @param {Login} login
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    login: async (
      login: Login,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'login' is not null or undefined
      assertParamExists("login", "login", login);
      const localVarPath = `/auth/login`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        login,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary LoginViaSingleUseCode
     * @param {LoginViaSingleUseCode} loginViaSingleUseCode
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    loginViaASingleUseCode: async (
      loginViaSingleUseCode: LoginViaSingleUseCode,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'loginViaSingleUseCode' is not null or undefined
      assertParamExists(
        "loginViaASingleUseCode",
        "loginViaSingleUseCode",
        loginViaSingleUseCode,
      );
      const localVarPath = `/auth/loginViaSingleUseCode`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        loginViaSingleUseCode,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Logout
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    logout: async (
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/auth/logout`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Request mfa code
     * @param {RequestMfaCode} requestMfaCode
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    requestMfaCode: async (
      requestMfaCode: RequestMfaCode,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'requestMfaCode' is not null or undefined
      assertParamExists("requestMfaCode", "requestMfaCode", requestMfaCode);
      const localVarPath = `/auth/request-mfa-code`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        requestMfaCode,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Requests a new token given a refresh token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    requestNewToken: async (
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/auth/requestNewToken`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Update Password
     * @param {UpdatePassword} updatePassword
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatePassword: async (
      updatePassword: UpdatePassword,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'updatePassword' is not null or undefined
      assertParamExists("updatePassword", "updatePassword", updatePassword);
      const localVarPath = `/auth/update-password`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        updatePassword,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * AuthApi - functional programming interface
 * @export
 */
export const AuthApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = AuthApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary Confirm email
     * @param {Confirm} confirm
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async confirm(
      confirm: Confirm,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessDTO>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.confirm(
        confirm,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["AuthApi.confirm"]?.[localVarOperationServerIndex]
          ?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Login
     * @param {Login} login
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async login(
      login: Login,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessDTO>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.login(
        login,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["AuthApi.login"]?.[localVarOperationServerIndex]
          ?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary LoginViaSingleUseCode
     * @param {LoginViaSingleUseCode} loginViaSingleUseCode
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async loginViaASingleUseCode(
      loginViaSingleUseCode: LoginViaSingleUseCode,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessDTO>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.loginViaASingleUseCode(
          loginViaSingleUseCode,
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["AuthApi.loginViaASingleUseCode"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Logout
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async logout(
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessDTO>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.logout(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["AuthApi.logout"]?.[localVarOperationServerIndex]
          ?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Request mfa code
     * @param {RequestMfaCode} requestMfaCode
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async requestMfaCode(
      requestMfaCode: RequestMfaCode,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<RequestMfaCodeResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.requestMfaCode(
        requestMfaCode,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["AuthApi.requestMfaCode"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Requests a new token given a refresh token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async requestNewToken(
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessDTO>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.requestNewToken(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["AuthApi.requestNewToken"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Update Password
     * @param {UpdatePassword} updatePassword
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updatePassword(
      updatePassword: UpdatePassword,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessDTO>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updatePassword(
        updatePassword,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["AuthApi.updatePassword"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * AuthApi - factory interface
 * @export
 */
export const AuthApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = AuthApiFp(configuration);
  return {
    /**
     *
     * @summary Confirm email
     * @param {Confirm} confirm
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    confirm(confirm: Confirm, options?: any): AxiosPromise<SuccessDTO> {
      return localVarFp
        .confirm(confirm, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Login
     * @param {Login} login
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    login(login: Login, options?: any): AxiosPromise<SuccessDTO> {
      return localVarFp
        .login(login, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary LoginViaSingleUseCode
     * @param {LoginViaSingleUseCode} loginViaSingleUseCode
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    loginViaASingleUseCode(
      loginViaSingleUseCode: LoginViaSingleUseCode,
      options?: any,
    ): AxiosPromise<SuccessDTO> {
      return localVarFp
        .loginViaASingleUseCode(loginViaSingleUseCode, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Logout
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    logout(options?: any): AxiosPromise<SuccessDTO> {
      return localVarFp
        .logout(options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Request mfa code
     * @param {RequestMfaCode} requestMfaCode
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    requestMfaCode(
      requestMfaCode: RequestMfaCode,
      options?: any,
    ): AxiosPromise<RequestMfaCodeResponse> {
      return localVarFp
        .requestMfaCode(requestMfaCode, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Requests a new token given a refresh token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    requestNewToken(options?: any): AxiosPromise<SuccessDTO> {
      return localVarFp
        .requestNewToken(options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Update Password
     * @param {UpdatePassword} updatePassword
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatePassword(
      updatePassword: UpdatePassword,
      options?: any,
    ): AxiosPromise<SuccessDTO> {
      return localVarFp
        .updatePassword(updatePassword, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi extends BaseAPI {
  /**
   *
   * @summary Confirm email
   * @param {Confirm} confirm
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthApi
   */
  public confirm(confirm: Confirm, options?: RawAxiosRequestConfig) {
    return AuthApiFp(this.configuration)
      .confirm(confirm, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Login
   * @param {Login} login
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthApi
   */
  public login(login: Login, options?: RawAxiosRequestConfig) {
    return AuthApiFp(this.configuration)
      .login(login, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary LoginViaSingleUseCode
   * @param {LoginViaSingleUseCode} loginViaSingleUseCode
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthApi
   */
  public loginViaASingleUseCode(
    loginViaSingleUseCode: LoginViaSingleUseCode,
    options?: RawAxiosRequestConfig,
  ) {
    return AuthApiFp(this.configuration)
      .loginViaASingleUseCode(loginViaSingleUseCode, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Logout
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthApi
   */
  public logout(options?: RawAxiosRequestConfig) {
    return AuthApiFp(this.configuration)
      .logout(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Request mfa code
   * @param {RequestMfaCode} requestMfaCode
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthApi
   */
  public requestMfaCode(
    requestMfaCode: RequestMfaCode,
    options?: RawAxiosRequestConfig,
  ) {
    return AuthApiFp(this.configuration)
      .requestMfaCode(requestMfaCode, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Requests a new token given a refresh token
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthApi
   */
  public requestNewToken(options?: RawAxiosRequestConfig) {
    return AuthApiFp(this.configuration)
      .requestNewToken(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Update Password
   * @param {UpdatePassword} updatePassword
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthApi
   */
  public updatePassword(
    updatePassword: UpdatePassword,
    options?: RawAxiosRequestConfig,
  ) {
    return AuthApiFp(this.configuration)
      .updatePassword(updatePassword, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * JurisdictionsApi - axios parameter creator
 * @export
 */
export const JurisdictionsApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     *
     * @summary Delete jurisdiction by id
     * @param {IdDTO} idDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    _delete: async (
      idDTO: IdDTO,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'idDTO' is not null or undefined
      assertParamExists("_delete", "idDTO", idDTO);
      const localVarPath = `/jurisdictions`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        idDTO,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Create jurisdiction
     * @param {JurisdictionCreate} jurisdictionCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    create: async (
      jurisdictionCreate: JurisdictionCreate,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'jurisdictionCreate' is not null or undefined
      assertParamExists("create", "jurisdictionCreate", jurisdictionCreate);
      const localVarPath = `/jurisdictions`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        jurisdictionCreate,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary List jurisdictions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    list: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/jurisdictions`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get jurisdiction by id
     * @param {string} jurisdictionId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    retrieve: async (
      jurisdictionId: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'jurisdictionId' is not null or undefined
      assertParamExists("retrieve", "jurisdictionId", jurisdictionId);
      const localVarPath = `/jurisdictions/{jurisdictionId}`.replace(
        `{${"jurisdictionId"}}`,
        encodeURIComponent(String(jurisdictionId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get jurisdiction by name
     * @param {string} jurisdictionName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    retrieveByName: async (
      jurisdictionName: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'jurisdictionName' is not null or undefined
      assertParamExists("retrieveByName", "jurisdictionName", jurisdictionName);
      const localVarPath = `/jurisdictions/byName/{jurisdictionName}`.replace(
        `{${"jurisdictionName"}}`,
        encodeURIComponent(String(jurisdictionName)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Update jurisdiction
     * @param {JurisdictionUpdate} jurisdictionUpdate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    update: async (
      jurisdictionUpdate: JurisdictionUpdate,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'jurisdictionUpdate' is not null or undefined
      assertParamExists("update", "jurisdictionUpdate", jurisdictionUpdate);
      const localVarPath = `/jurisdictions/{jurisdictionId}`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        jurisdictionUpdate,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * JurisdictionsApi - functional programming interface
 * @export
 */
export const JurisdictionsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    JurisdictionsApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary Delete jurisdiction by id
     * @param {IdDTO} idDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async _delete(
      idDTO: IdDTO,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessDTO>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator._delete(
        idDTO,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["JurisdictionsApi._delete"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Create jurisdiction
     * @param {JurisdictionCreate} jurisdictionCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async create(
      jurisdictionCreate: JurisdictionCreate,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Jurisdiction>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.create(
        jurisdictionCreate,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["JurisdictionsApi.create"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary List jurisdictions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async list(
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<Array<Jurisdiction>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.list(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["JurisdictionsApi.list"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Get jurisdiction by id
     * @param {string} jurisdictionId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async retrieve(
      jurisdictionId: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Jurisdiction>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.retrieve(
        jurisdictionId,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["JurisdictionsApi.retrieve"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Get jurisdiction by name
     * @param {string} jurisdictionName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async retrieveByName(
      jurisdictionName: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Jurisdiction>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveByName(
        jurisdictionName,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["JurisdictionsApi.retrieveByName"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Update jurisdiction
     * @param {JurisdictionUpdate} jurisdictionUpdate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async update(
      jurisdictionUpdate: JurisdictionUpdate,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Jurisdiction>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.update(
        jurisdictionUpdate,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["JurisdictionsApi.update"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * JurisdictionsApi - factory interface
 * @export
 */
export const JurisdictionsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = JurisdictionsApiFp(configuration);
  return {
    /**
     *
     * @summary Delete jurisdiction by id
     * @param {IdDTO} idDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    _delete(idDTO: IdDTO, options?: any): AxiosPromise<SuccessDTO> {
      return localVarFp
        ._delete(idDTO, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Create jurisdiction
     * @param {JurisdictionCreate} jurisdictionCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    create(
      jurisdictionCreate: JurisdictionCreate,
      options?: any,
    ): AxiosPromise<Jurisdiction> {
      return localVarFp
        .create(jurisdictionCreate, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary List jurisdictions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    list(options?: any): AxiosPromise<Array<Jurisdiction>> {
      return localVarFp
        .list(options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get jurisdiction by id
     * @param {string} jurisdictionId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    retrieve(
      jurisdictionId: string,
      options?: any,
    ): AxiosPromise<Jurisdiction> {
      return localVarFp
        .retrieve(jurisdictionId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get jurisdiction by name
     * @param {string} jurisdictionName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    retrieveByName(
      jurisdictionName: string,
      options?: any,
    ): AxiosPromise<Jurisdiction> {
      return localVarFp
        .retrieveByName(jurisdictionName, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Update jurisdiction
     * @param {JurisdictionUpdate} jurisdictionUpdate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    update(
      jurisdictionUpdate: JurisdictionUpdate,
      options?: any,
    ): AxiosPromise<Jurisdiction> {
      return localVarFp
        .update(jurisdictionUpdate, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * JurisdictionsApi - object-oriented interface
 * @export
 * @class JurisdictionsApi
 * @extends {BaseAPI}
 */
export class JurisdictionsApi extends BaseAPI {
  /**
   *
   * @summary Delete jurisdiction by id
   * @param {IdDTO} idDTO
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof JurisdictionsApi
   */
  public _delete(idDTO: IdDTO, options?: RawAxiosRequestConfig) {
    return JurisdictionsApiFp(this.configuration)
      ._delete(idDTO, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Create jurisdiction
   * @param {JurisdictionCreate} jurisdictionCreate
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof JurisdictionsApi
   */
  public create(
    jurisdictionCreate: JurisdictionCreate,
    options?: RawAxiosRequestConfig,
  ) {
    return JurisdictionsApiFp(this.configuration)
      .create(jurisdictionCreate, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary List jurisdictions
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof JurisdictionsApi
   */
  public list(options?: RawAxiosRequestConfig) {
    return JurisdictionsApiFp(this.configuration)
      .list(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get jurisdiction by id
   * @param {string} jurisdictionId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof JurisdictionsApi
   */
  public retrieve(jurisdictionId: string, options?: RawAxiosRequestConfig) {
    return JurisdictionsApiFp(this.configuration)
      .retrieve(jurisdictionId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get jurisdiction by name
   * @param {string} jurisdictionName
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof JurisdictionsApi
   */
  public retrieveByName(
    jurisdictionName: string,
    options?: RawAxiosRequestConfig,
  ) {
    return JurisdictionsApiFp(this.configuration)
      .retrieveByName(jurisdictionName, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Update jurisdiction
   * @param {JurisdictionUpdate} jurisdictionUpdate
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof JurisdictionsApi
   */
  public update(
    jurisdictionUpdate: JurisdictionUpdate,
    options?: RawAxiosRequestConfig,
  ) {
    return JurisdictionsApiFp(this.configuration)
      .update(jurisdictionUpdate, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * ListingsApi - axios parameter creator
 * @export
 */
export const ListingsApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     *
     * @summary Delete listing by id
     * @param {IdDTO} idDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    _delete: async (
      idDTO: IdDTO,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'idDTO' is not null or undefined
      assertParamExists("_delete", "idDTO", idDTO);
      const localVarPath = `/listings`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        idDTO,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Create listing
     * @param {ListingCreate} listingCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    create: async (
      listingCreate: ListingCreate,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'listingCreate' is not null or undefined
      assertParamExists("create", "listingCreate", listingCreate);
      const localVarPath = `/listings`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        listingCreate,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Duplicate listing
     * @param {ListingDuplicate} listingDuplicate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    duplicate: async (
      listingDuplicate: ListingDuplicate,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'listingDuplicate' is not null or undefined
      assertParamExists("duplicate", "listingDuplicate", listingDuplicate);
      const localVarPath = `/listings/duplicate`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        listingDuplicate,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get listing for external consumption by id
     * @param {string} language
     * @param {string} id
     * @param {ListingViews} [view]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    externalRetrieve: async (
      language: string,
      id: string,
      view?: ListingViews,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'language' is not null or undefined
      assertParamExists("externalRetrieve", "language", language);
      // verify required parameter 'id' is not null or undefined
      assertParamExists("externalRetrieve", "id", id);
      const localVarPath = `/listings/external/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (view !== undefined) {
        localVarQueryParameter["view"] = view;
      }

      if (language != null) {
        localVarHeaderParameter["language"] = String(language);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get a paginated set of listings
     * @param {number} [page]
     * @param {number} [limit]
     * @param {Array<ListingFilterParams>} [filter]
     * @param {ListingViews} [view]
     * @param {ListingOrderByKeys} [orderBy]
     * @param {OrderByEnum} [orderDir]
     * @param {string} [search]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    list: async (
      page?: number,
      limit?: number,
      filter?: Array<ListingFilterParams>,
      view?: ListingViews,
      orderBy?: ListingOrderByKeys,
      orderDir?: OrderByEnum,
      search?: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/listings`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (page !== undefined) {
        localVarQueryParameter["page"] = page;
      }

      if (limit !== undefined) {
        localVarQueryParameter["limit"] = limit;
      }

      if (filter) {
        localVarQueryParameter["filter"] = filter;
      }

      if (view !== undefined) {
        localVarQueryParameter["view"] = view;
      }

      if (orderBy !== undefined) {
        localVarQueryParameter["orderBy"] = orderBy;
      }

      if (orderDir !== undefined) {
        localVarQueryParameter["orderDir"] = orderDir;
      }

      if (search !== undefined) {
        localVarQueryParameter["search"] = search;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get listings and units as zip
     * @param {string} [timeZone]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listAsCsv: async (
      timeZone?: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/listings/csv`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (timeZone !== undefined) {
        localVarQueryParameter["timeZone"] = timeZone;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary List all local and external listings
     * @param {number} [page]
     * @param {number} [limit]
     * @param {Array<ListingFilterParams>} [filter]
     * @param {ListingViews} [view]
     * @param {ListingOrderByKeys} [orderBy]
     * @param {OrderByEnum} [orderDir]
     * @param {string} [search]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listCombined: async (
      page?: number,
      limit?: number,
      filter?: Array<ListingFilterParams>,
      view?: ListingViews,
      orderBy?: ListingOrderByKeys,
      orderDir?: OrderByEnum,
      search?: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/listings/combined`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (page !== undefined) {
        localVarQueryParameter["page"] = page;
      }

      if (limit !== undefined) {
        localVarQueryParameter["limit"] = limit;
      }

      if (filter) {
        localVarQueryParameter["filter"] = filter;
      }

      if (view !== undefined) {
        localVarQueryParameter["view"] = view;
      }

      if (orderBy !== undefined) {
        localVarQueryParameter["orderBy"] = orderBy;
      }

      if (orderDir !== undefined) {
        localVarQueryParameter["orderDir"] = orderDir;
      }

      if (search !== undefined) {
        localVarQueryParameter["search"] = search;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Trigger the listing process job
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    process: async (
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/listings/closeListings`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get listing by id
     * @param {string} language
     * @param {string} id
     * @param {ListingViews} [view]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    retrieve: async (
      language: string,
      id: string,
      view?: ListingViews,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'language' is not null or undefined
      assertParamExists("retrieve", "language", language);
      // verify required parameter 'id' is not null or undefined
      assertParamExists("retrieve", "id", id);
      const localVarPath = `/listings/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (view !== undefined) {
        localVarQueryParameter["view"] = view;
      }

      if (language != null) {
        localVarHeaderParameter["language"] = String(language);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get listings by multiselect question id
     * @param {string} multiselectQuestionId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    retrieveListings: async (
      multiselectQuestionId: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'multiselectQuestionId' is not null or undefined
      assertParamExists(
        "retrieveListings",
        "multiselectQuestionId",
        multiselectQuestionId,
      );
      const localVarPath =
        `/listings/byMultiselectQuestion/{multiselectQuestionId}`.replace(
          `{${"multiselectQuestionId"}}`,
          encodeURIComponent(String(multiselectQuestionId)),
        );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Update listing by id
     * @param {string} id
     * @param {ListingUpdate} listingUpdate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    update: async (
      id: string,
      listingUpdate: ListingUpdate,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("update", "id", id);
      // verify required parameter 'listingUpdate' is not null or undefined
      assertParamExists("update", "listingUpdate", listingUpdate);
      const localVarPath = `/listings/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        listingUpdate,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * ListingsApi - functional programming interface
 * @export
 */
export const ListingsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = ListingsApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary Delete listing by id
     * @param {IdDTO} idDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async _delete(
      idDTO: IdDTO,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator._delete(
        idDTO,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ListingsApi._delete"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Create listing
     * @param {ListingCreate} listingCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async create(
      listingCreate: ListingCreate,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Listing>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.create(
        listingCreate,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ListingsApi.create"]?.[localVarOperationServerIndex]
          ?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Duplicate listing
     * @param {ListingDuplicate} listingDuplicate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async duplicate(
      listingDuplicate: ListingDuplicate,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Listing>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.duplicate(
        listingDuplicate,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ListingsApi.duplicate"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Get listing for external consumption by id
     * @param {string} language
     * @param {string} id
     * @param {ListingViews} [view]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async externalRetrieve(
      language: string,
      id: string,
      view?: ListingViews,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.externalRetrieve(
          language,
          id,
          view,
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ListingsApi.externalRetrieve"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Get a paginated set of listings
     * @param {number} [page]
     * @param {number} [limit]
     * @param {Array<ListingFilterParams>} [filter]
     * @param {ListingViews} [view]
     * @param {ListingOrderByKeys} [orderBy]
     * @param {OrderByEnum} [orderDir]
     * @param {string} [search]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async list(
      page?: number,
      limit?: number,
      filter?: Array<ListingFilterParams>,
      view?: ListingViews,
      orderBy?: ListingOrderByKeys,
      orderDir?: OrderByEnum,
      search?: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<PaginatedListingDto>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.list(
        page,
        limit,
        filter,
        view,
        orderBy,
        orderDir,
        search,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ListingsApi.list"]?.[localVarOperationServerIndex]
          ?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Get listings and units as zip
     * @param {string} [timeZone]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listAsCsv(
      timeZone?: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listAsCsv(
        timeZone,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ListingsApi.listAsCsv"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary List all local and external listings
     * @param {number} [page]
     * @param {number} [limit]
     * @param {Array<ListingFilterParams>} [filter]
     * @param {ListingViews} [view]
     * @param {ListingOrderByKeys} [orderBy]
     * @param {OrderByEnum} [orderDir]
     * @param {string} [search]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listCombined(
      page?: number,
      limit?: number,
      filter?: Array<ListingFilterParams>,
      view?: ListingViews,
      orderBy?: ListingOrderByKeys,
      orderDir?: OrderByEnum,
      search?: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listCombined(
        page,
        limit,
        filter,
        view,
        orderBy,
        orderDir,
        search,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ListingsApi.listCombined"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Trigger the listing process job
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async process(
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessDTO>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.process(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ListingsApi.process"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Get listing by id
     * @param {string} language
     * @param {string} id
     * @param {ListingViews} [view]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async retrieve(
      language: string,
      id: string,
      view?: ListingViews,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Listing>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.retrieve(
        language,
        id,
        view,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ListingsApi.retrieve"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Get listings by multiselect question id
     * @param {string} multiselectQuestionId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async retrieveListings(
      multiselectQuestionId: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<IdDTO>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.retrieveListings(
          multiselectQuestionId,
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ListingsApi.retrieveListings"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Update listing by id
     * @param {string} id
     * @param {ListingUpdate} listingUpdate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async update(
      id: string,
      listingUpdate: ListingUpdate,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Listing>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.update(
        id,
        listingUpdate,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ListingsApi.update"]?.[localVarOperationServerIndex]
          ?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * ListingsApi - factory interface
 * @export
 */
export const ListingsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = ListingsApiFp(configuration);
  return {
    /**
     *
     * @summary Delete listing by id
     * @param {IdDTO} idDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    _delete(idDTO: IdDTO, options?: any): AxiosPromise<void> {
      return localVarFp
        ._delete(idDTO, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Create listing
     * @param {ListingCreate} listingCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    create(listingCreate: ListingCreate, options?: any): AxiosPromise<Listing> {
      return localVarFp
        .create(listingCreate, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Duplicate listing
     * @param {ListingDuplicate} listingDuplicate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    duplicate(
      listingDuplicate: ListingDuplicate,
      options?: any,
    ): AxiosPromise<Listing> {
      return localVarFp
        .duplicate(listingDuplicate, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get listing for external consumption by id
     * @param {string} language
     * @param {string} id
     * @param {ListingViews} [view]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    externalRetrieve(
      language: string,
      id: string,
      view?: ListingViews,
      options?: any,
    ): AxiosPromise<string> {
      return localVarFp
        .externalRetrieve(language, id, view, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get a paginated set of listings
     * @param {number} [page]
     * @param {number} [limit]
     * @param {Array<ListingFilterParams>} [filter]
     * @param {ListingViews} [view]
     * @param {ListingOrderByKeys} [orderBy]
     * @param {OrderByEnum} [orderDir]
     * @param {string} [search]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    list(
      page?: number,
      limit?: number,
      filter?: Array<ListingFilterParams>,
      view?: ListingViews,
      orderBy?: ListingOrderByKeys,
      orderDir?: OrderByEnum,
      search?: string,
      options?: any,
    ): AxiosPromise<PaginatedListingDto> {
      return localVarFp
        .list(page, limit, filter, view, orderBy, orderDir, search, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get listings and units as zip
     * @param {string} [timeZone]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listAsCsv(timeZone?: string, options?: any): AxiosPromise<void> {
      return localVarFp
        .listAsCsv(timeZone, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary List all local and external listings
     * @param {number} [page]
     * @param {number} [limit]
     * @param {Array<ListingFilterParams>} [filter]
     * @param {ListingViews} [view]
     * @param {ListingOrderByKeys} [orderBy]
     * @param {OrderByEnum} [orderDir]
     * @param {string} [search]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listCombined(
      page?: number,
      limit?: number,
      filter?: Array<ListingFilterParams>,
      view?: ListingViews,
      orderBy?: ListingOrderByKeys,
      orderDir?: OrderByEnum,
      search?: string,
      options?: any,
    ): AxiosPromise<void> {
      return localVarFp
        .listCombined(
          page,
          limit,
          filter,
          view,
          orderBy,
          orderDir,
          search,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Trigger the listing process job
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    process(options?: any): AxiosPromise<SuccessDTO> {
      return localVarFp
        .process(options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get listing by id
     * @param {string} language
     * @param {string} id
     * @param {ListingViews} [view]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    retrieve(
      language: string,
      id: string,
      view?: ListingViews,
      options?: any,
    ): AxiosPromise<Listing> {
      return localVarFp
        .retrieve(language, id, view, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get listings by multiselect question id
     * @param {string} multiselectQuestionId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    retrieveListings(
      multiselectQuestionId: string,
      options?: any,
    ): AxiosPromise<Array<IdDTO>> {
      return localVarFp
        .retrieveListings(multiselectQuestionId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Update listing by id
     * @param {string} id
     * @param {ListingUpdate} listingUpdate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    update(
      id: string,
      listingUpdate: ListingUpdate,
      options?: any,
    ): AxiosPromise<Listing> {
      return localVarFp
        .update(id, listingUpdate, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * ListingsApi - object-oriented interface
 * @export
 * @class ListingsApi
 * @extends {BaseAPI}
 */
export class ListingsApi extends BaseAPI {
  /**
   *
   * @summary Delete listing by id
   * @param {IdDTO} idDTO
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ListingsApi
   */
  public _delete(idDTO: IdDTO, options?: RawAxiosRequestConfig) {
    return ListingsApiFp(this.configuration)
      ._delete(idDTO, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Create listing
   * @param {ListingCreate} listingCreate
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ListingsApi
   */
  public create(listingCreate: ListingCreate, options?: RawAxiosRequestConfig) {
    return ListingsApiFp(this.configuration)
      .create(listingCreate, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Duplicate listing
   * @param {ListingDuplicate} listingDuplicate
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ListingsApi
   */
  public duplicate(
    listingDuplicate: ListingDuplicate,
    options?: RawAxiosRequestConfig,
  ) {
    return ListingsApiFp(this.configuration)
      .duplicate(listingDuplicate, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get listing for external consumption by id
   * @param {string} language
   * @param {string} id
   * @param {ListingViews} [view]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ListingsApi
   */
  public externalRetrieve(
    language: string,
    id: string,
    view?: ListingViews,
    options?: RawAxiosRequestConfig,
  ) {
    return ListingsApiFp(this.configuration)
      .externalRetrieve(language, id, view, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get a paginated set of listings
   * @param {number} [page]
   * @param {number} [limit]
   * @param {Array<ListingFilterParams>} [filter]
   * @param {ListingViews} [view]
   * @param {ListingOrderByKeys} [orderBy]
   * @param {OrderByEnum} [orderDir]
   * @param {string} [search]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ListingsApi
   */
  public list(
    page?: number,
    limit?: number,
    filter?: Array<ListingFilterParams>,
    view?: ListingViews,
    orderBy?: ListingOrderByKeys,
    orderDir?: OrderByEnum,
    search?: string,
    options?: RawAxiosRequestConfig,
  ) {
    return ListingsApiFp(this.configuration)
      .list(page, limit, filter, view, orderBy, orderDir, search, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get listings and units as zip
   * @param {string} [timeZone]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ListingsApi
   */
  public listAsCsv(timeZone?: string, options?: RawAxiosRequestConfig) {
    return ListingsApiFp(this.configuration)
      .listAsCsv(timeZone, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary List all local and external listings
   * @param {number} [page]
   * @param {number} [limit]
   * @param {Array<ListingFilterParams>} [filter]
   * @param {ListingViews} [view]
   * @param {ListingOrderByKeys} [orderBy]
   * @param {OrderByEnum} [orderDir]
   * @param {string} [search]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ListingsApi
   */
  public listCombined(
    page?: number,
    limit?: number,
    filter?: Array<ListingFilterParams>,
    view?: ListingViews,
    orderBy?: ListingOrderByKeys,
    orderDir?: OrderByEnum,
    search?: string,
    options?: RawAxiosRequestConfig,
  ) {
    return ListingsApiFp(this.configuration)
      .listCombined(
        page,
        limit,
        filter,
        view,
        orderBy,
        orderDir,
        search,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Trigger the listing process job
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ListingsApi
   */
  public process(options?: RawAxiosRequestConfig) {
    return ListingsApiFp(this.configuration)
      .process(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get listing by id
   * @param {string} language
   * @param {string} id
   * @param {ListingViews} [view]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ListingsApi
   */
  public retrieve(
    language: string,
    id: string,
    view?: ListingViews,
    options?: RawAxiosRequestConfig,
  ) {
    return ListingsApiFp(this.configuration)
      .retrieve(language, id, view, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get listings by multiselect question id
   * @param {string} multiselectQuestionId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ListingsApi
   */
  public retrieveListings(
    multiselectQuestionId: string,
    options?: RawAxiosRequestConfig,
  ) {
    return ListingsApiFp(this.configuration)
      .retrieveListings(multiselectQuestionId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Update listing by id
   * @param {string} id
   * @param {ListingUpdate} listingUpdate
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ListingsApi
   */
  public update(
    id: string,
    listingUpdate: ListingUpdate,
    options?: RawAxiosRequestConfig,
  ) {
    return ListingsApiFp(this.configuration)
      .update(id, listingUpdate, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * LotteryApi - axios parameter creator
 * @export
 */
export const LotteryApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     *
     * @summary Trigger the lottery auto publish process job
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    autoPublishResults: async (
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/lottery/autoPublishResults`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Trigger the lottery expiration process job
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    expireLotteries: async (
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/lottery/expireLotteries`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get a lottery activity log
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    lotteryActivityLog: async (
      id: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("lotteryActivityLog", "id", id);
      const localVarPath = `/lottery/lotteryActivityLog/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Generate the lottery results for a listing
     * @param {ApplicationCsvQueryParams} applicationCsvQueryParams
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    lotteryGenerate: async (
      applicationCsvQueryParams: ApplicationCsvQueryParams,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'applicationCsvQueryParams' is not null or undefined
      assertParamExists(
        "lotteryGenerate",
        "applicationCsvQueryParams",
        applicationCsvQueryParams,
      );
      const localVarPath = `/lottery/generateLotteryResults`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        applicationCsvQueryParams,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get applications lottery results
     * @param {string} id
     * @param {boolean} [includeDemographics]
     * @param {string} [timeZone]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    lotteryResults: async (
      id: string,
      includeDemographics?: boolean,
      timeZone?: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("lotteryResults", "id", id);
      const localVarPath = `/lottery/getLotteryResults`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (id !== undefined) {
        localVarQueryParameter["id"] = id;
      }

      if (includeDemographics !== undefined) {
        localVarQueryParameter["includeDemographics"] = includeDemographics;
      }

      if (timeZone !== undefined) {
        localVarQueryParameter["timeZone"] = timeZone;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Change the listing lottery status
     * @param {ListingLotteryStatus} listingLotteryStatus
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    lotteryStatus: async (
      listingLotteryStatus: ListingLotteryStatus,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'listingLotteryStatus' is not null or undefined
      assertParamExists(
        "lotteryStatus",
        "listingLotteryStatus",
        listingLotteryStatus,
      );
      const localVarPath = `/lottery/lotteryStatus`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        listingLotteryStatus,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get lottery totals by listing id
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    lotteryTotals: async (
      id: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("lotteryTotals", "id", id);
      const localVarPath = `/lottery/lotteryTotals/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get lottery results by application id
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    publicLotteryResults: async (
      id: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("publicLotteryResults", "id", id);
      const localVarPath = `/lottery/publicLotteryResults/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * LotteryApi - functional programming interface
 * @export
 */
export const LotteryApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = LotteryApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary Trigger the lottery auto publish process job
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async autoPublishResults(
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessDTO>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.autoPublishResults(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["LotteryApi.autoPublishResults"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Trigger the lottery expiration process job
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async expireLotteries(
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessDTO>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.expireLotteries(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["LotteryApi.expireLotteries"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Get a lottery activity log
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async lotteryActivityLog(
      id: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<Array<LotteryActivityLogItem>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.lotteryActivityLog(id, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["LotteryApi.lotteryActivityLog"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Generate the lottery results for a listing
     * @param {ApplicationCsvQueryParams} applicationCsvQueryParams
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async lotteryGenerate(
      applicationCsvQueryParams: ApplicationCsvQueryParams,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.lotteryGenerate(
        applicationCsvQueryParams,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["LotteryApi.lotteryGenerate"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Get applications lottery results
     * @param {string} id
     * @param {boolean} [includeDemographics]
     * @param {string} [timeZone]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async lotteryResults(
      id: string,
      includeDemographics?: boolean,
      timeZone?: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.lotteryResults(
        id,
        includeDemographics,
        timeZone,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["LotteryApi.lotteryResults"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Change the listing lottery status
     * @param {ListingLotteryStatus} listingLotteryStatus
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async lotteryStatus(
      listingLotteryStatus: ListingLotteryStatus,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessDTO>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.lotteryStatus(
        listingLotteryStatus,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["LotteryApi.lotteryStatus"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Get lottery totals by listing id
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async lotteryTotals(
      id: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<Array<PublicLotteryTotal>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.lotteryTotals(
        id,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["LotteryApi.lotteryTotals"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Get lottery results by application id
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async publicLotteryResults(
      id: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<Array<PublicLotteryResult>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.publicLotteryResults(id, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["LotteryApi.publicLotteryResults"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * LotteryApi - factory interface
 * @export
 */
export const LotteryApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = LotteryApiFp(configuration);
  return {
    /**
     *
     * @summary Trigger the lottery auto publish process job
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    autoPublishResults(options?: any): AxiosPromise<SuccessDTO> {
      return localVarFp
        .autoPublishResults(options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Trigger the lottery expiration process job
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    expireLotteries(options?: any): AxiosPromise<SuccessDTO> {
      return localVarFp
        .expireLotteries(options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get a lottery activity log
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    lotteryActivityLog(
      id: string,
      options?: any,
    ): AxiosPromise<Array<LotteryActivityLogItem>> {
      return localVarFp
        .lotteryActivityLog(id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Generate the lottery results for a listing
     * @param {ApplicationCsvQueryParams} applicationCsvQueryParams
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    lotteryGenerate(
      applicationCsvQueryParams: ApplicationCsvQueryParams,
      options?: any,
    ): AxiosPromise<void> {
      return localVarFp
        .lotteryGenerate(applicationCsvQueryParams, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get applications lottery results
     * @param {string} id
     * @param {boolean} [includeDemographics]
     * @param {string} [timeZone]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    lotteryResults(
      id: string,
      includeDemographics?: boolean,
      timeZone?: string,
      options?: any,
    ): AxiosPromise<void> {
      return localVarFp
        .lotteryResults(id, includeDemographics, timeZone, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Change the listing lottery status
     * @param {ListingLotteryStatus} listingLotteryStatus
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    lotteryStatus(
      listingLotteryStatus: ListingLotteryStatus,
      options?: any,
    ): AxiosPromise<SuccessDTO> {
      return localVarFp
        .lotteryStatus(listingLotteryStatus, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get lottery totals by listing id
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    lotteryTotals(
      id: string,
      options?: any,
    ): AxiosPromise<Array<PublicLotteryTotal>> {
      return localVarFp
        .lotteryTotals(id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get lottery results by application id
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    publicLotteryResults(
      id: string,
      options?: any,
    ): AxiosPromise<Array<PublicLotteryResult>> {
      return localVarFp
        .publicLotteryResults(id, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * LotteryApi - object-oriented interface
 * @export
 * @class LotteryApi
 * @extends {BaseAPI}
 */
export class LotteryApi extends BaseAPI {
  /**
   *
   * @summary Trigger the lottery auto publish process job
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LotteryApi
   */
  public autoPublishResults(options?: RawAxiosRequestConfig) {
    return LotteryApiFp(this.configuration)
      .autoPublishResults(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Trigger the lottery expiration process job
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LotteryApi
   */
  public expireLotteries(options?: RawAxiosRequestConfig) {
    return LotteryApiFp(this.configuration)
      .expireLotteries(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get a lottery activity log
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LotteryApi
   */
  public lotteryActivityLog(id: string, options?: RawAxiosRequestConfig) {
    return LotteryApiFp(this.configuration)
      .lotteryActivityLog(id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Generate the lottery results for a listing
   * @param {ApplicationCsvQueryParams} applicationCsvQueryParams
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LotteryApi
   */
  public lotteryGenerate(
    applicationCsvQueryParams: ApplicationCsvQueryParams,
    options?: RawAxiosRequestConfig,
  ) {
    return LotteryApiFp(this.configuration)
      .lotteryGenerate(applicationCsvQueryParams, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get applications lottery results
   * @param {string} id
   * @param {boolean} [includeDemographics]
   * @param {string} [timeZone]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LotteryApi
   */
  public lotteryResults(
    id: string,
    includeDemographics?: boolean,
    timeZone?: string,
    options?: RawAxiosRequestConfig,
  ) {
    return LotteryApiFp(this.configuration)
      .lotteryResults(id, includeDemographics, timeZone, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Change the listing lottery status
   * @param {ListingLotteryStatus} listingLotteryStatus
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LotteryApi
   */
  public lotteryStatus(
    listingLotteryStatus: ListingLotteryStatus,
    options?: RawAxiosRequestConfig,
  ) {
    return LotteryApiFp(this.configuration)
      .lotteryStatus(listingLotteryStatus, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get lottery totals by listing id
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LotteryApi
   */
  public lotteryTotals(id: string, options?: RawAxiosRequestConfig) {
    return LotteryApiFp(this.configuration)
      .lotteryTotals(id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get lottery results by application id
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LotteryApi
   */
  public publicLotteryResults(id: string, options?: RawAxiosRequestConfig) {
    return LotteryApiFp(this.configuration)
      .publicLotteryResults(id, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * MapLayersApi - axios parameter creator
 * @export
 */
export const MapLayersApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     *
     * @summary List map layers
     * @param {string} [jurisdictionId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    list: async (
      jurisdictionId?: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/mapLayers`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (jurisdictionId !== undefined) {
        localVarQueryParameter["jurisdictionId"] = jurisdictionId;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * MapLayersApi - functional programming interface
 * @export
 */
export const MapLayersApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    MapLayersApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary List map layers
     * @param {string} [jurisdictionId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async list(
      jurisdictionId?: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<Array<MapLayerDto>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.list(
        jurisdictionId,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["MapLayersApi.list"]?.[localVarOperationServerIndex]
          ?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * MapLayersApi - factory interface
 * @export
 */
export const MapLayersApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = MapLayersApiFp(configuration);
  return {
    /**
     *
     * @summary List map layers
     * @param {string} [jurisdictionId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    list(
      jurisdictionId?: string,
      options?: any,
    ): AxiosPromise<Array<MapLayerDto>> {
      return localVarFp
        .list(jurisdictionId, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * MapLayersApi - object-oriented interface
 * @export
 * @class MapLayersApi
 * @extends {BaseAPI}
 */
export class MapLayersApi extends BaseAPI {
  /**
   *
   * @summary List map layers
   * @param {string} [jurisdictionId]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MapLayersApi
   */
  public list(jurisdictionId?: string, options?: RawAxiosRequestConfig) {
    return MapLayersApiFp(this.configuration)
      .list(jurisdictionId, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * MultiselectQuestionsApi - axios parameter creator
 * @export
 */
export const MultiselectQuestionsApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     *
     * @summary Delete multiselect question by id
     * @param {IdDTO} idDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    _delete: async (
      idDTO: IdDTO,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'idDTO' is not null or undefined
      assertParamExists("_delete", "idDTO", idDTO);
      const localVarPath = `/multiselectQuestions`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        idDTO,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Create multiselect question
     * @param {MultiselectQuestionCreate} multiselectQuestionCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    create: async (
      multiselectQuestionCreate: MultiselectQuestionCreate,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'multiselectQuestionCreate' is not null or undefined
      assertParamExists(
        "create",
        "multiselectQuestionCreate",
        multiselectQuestionCreate,
      );
      const localVarPath = `/multiselectQuestions`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        multiselectQuestionCreate,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary List multiselect questions
     * @param {Array<MultiselectQuestionFilterParams>} [filter]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    list: async (
      filter?: Array<MultiselectQuestionFilterParams>,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/multiselectQuestions`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (filter) {
        localVarQueryParameter["filter"] = filter;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get multiselect question by id
     * @param {string} multiselectQuestionId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    retrieve: async (
      multiselectQuestionId: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'multiselectQuestionId' is not null or undefined
      assertParamExists(
        "retrieve",
        "multiselectQuestionId",
        multiselectQuestionId,
      );
      const localVarPath =
        `/multiselectQuestions/{multiselectQuestionId}`.replace(
          `{${"multiselectQuestionId"}}`,
          encodeURIComponent(String(multiselectQuestionId)),
        );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Update multiselect question
     * @param {MultiselectQuestionUpdate} multiselectQuestionUpdate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    update: async (
      multiselectQuestionUpdate: MultiselectQuestionUpdate,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'multiselectQuestionUpdate' is not null or undefined
      assertParamExists(
        "update",
        "multiselectQuestionUpdate",
        multiselectQuestionUpdate,
      );
      const localVarPath = `/multiselectQuestions/{multiselectQuestionId}`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        multiselectQuestionUpdate,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * MultiselectQuestionsApi - functional programming interface
 * @export
 */
export const MultiselectQuestionsApiFp = function (
  configuration?: Configuration,
) {
  const localVarAxiosParamCreator =
    MultiselectQuestionsApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary Delete multiselect question by id
     * @param {IdDTO} idDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async _delete(
      idDTO: IdDTO,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessDTO>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator._delete(
        idDTO,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["MultiselectQuestionsApi._delete"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Create multiselect question
     * @param {MultiselectQuestionCreate} multiselectQuestionCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async create(
      multiselectQuestionCreate: MultiselectQuestionCreate,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<MultiselectQuestion>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.create(
        multiselectQuestionCreate,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["MultiselectQuestionsApi.create"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary List multiselect questions
     * @param {Array<MultiselectQuestionFilterParams>} [filter]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async list(
      filter?: Array<MultiselectQuestionFilterParams>,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<Array<MultiselectQuestion>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.list(
        filter,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["MultiselectQuestionsApi.list"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Get multiselect question by id
     * @param {string} multiselectQuestionId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async retrieve(
      multiselectQuestionId: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<MultiselectQuestion>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.retrieve(
        multiselectQuestionId,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["MultiselectQuestionsApi.retrieve"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Update multiselect question
     * @param {MultiselectQuestionUpdate} multiselectQuestionUpdate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async update(
      multiselectQuestionUpdate: MultiselectQuestionUpdate,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<MultiselectQuestion>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.update(
        multiselectQuestionUpdate,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["MultiselectQuestionsApi.update"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * MultiselectQuestionsApi - factory interface
 * @export
 */
export const MultiselectQuestionsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = MultiselectQuestionsApiFp(configuration);
  return {
    /**
     *
     * @summary Delete multiselect question by id
     * @param {IdDTO} idDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    _delete(idDTO: IdDTO, options?: any): AxiosPromise<SuccessDTO> {
      return localVarFp
        ._delete(idDTO, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Create multiselect question
     * @param {MultiselectQuestionCreate} multiselectQuestionCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    create(
      multiselectQuestionCreate: MultiselectQuestionCreate,
      options?: any,
    ): AxiosPromise<MultiselectQuestion> {
      return localVarFp
        .create(multiselectQuestionCreate, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary List multiselect questions
     * @param {Array<MultiselectQuestionFilterParams>} [filter]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    list(
      filter?: Array<MultiselectQuestionFilterParams>,
      options?: any,
    ): AxiosPromise<Array<MultiselectQuestion>> {
      return localVarFp
        .list(filter, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get multiselect question by id
     * @param {string} multiselectQuestionId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    retrieve(
      multiselectQuestionId: string,
      options?: any,
    ): AxiosPromise<MultiselectQuestion> {
      return localVarFp
        .retrieve(multiselectQuestionId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Update multiselect question
     * @param {MultiselectQuestionUpdate} multiselectQuestionUpdate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    update(
      multiselectQuestionUpdate: MultiselectQuestionUpdate,
      options?: any,
    ): AxiosPromise<MultiselectQuestion> {
      return localVarFp
        .update(multiselectQuestionUpdate, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * MultiselectQuestionsApi - object-oriented interface
 * @export
 * @class MultiselectQuestionsApi
 * @extends {BaseAPI}
 */
export class MultiselectQuestionsApi extends BaseAPI {
  /**
   *
   * @summary Delete multiselect question by id
   * @param {IdDTO} idDTO
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MultiselectQuestionsApi
   */
  public _delete(idDTO: IdDTO, options?: RawAxiosRequestConfig) {
    return MultiselectQuestionsApiFp(this.configuration)
      ._delete(idDTO, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Create multiselect question
   * @param {MultiselectQuestionCreate} multiselectQuestionCreate
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MultiselectQuestionsApi
   */
  public create(
    multiselectQuestionCreate: MultiselectQuestionCreate,
    options?: RawAxiosRequestConfig,
  ) {
    return MultiselectQuestionsApiFp(this.configuration)
      .create(multiselectQuestionCreate, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary List multiselect questions
   * @param {Array<MultiselectQuestionFilterParams>} [filter]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MultiselectQuestionsApi
   */
  public list(
    filter?: Array<MultiselectQuestionFilterParams>,
    options?: RawAxiosRequestConfig,
  ) {
    return MultiselectQuestionsApiFp(this.configuration)
      .list(filter, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get multiselect question by id
   * @param {string} multiselectQuestionId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MultiselectQuestionsApi
   */
  public retrieve(
    multiselectQuestionId: string,
    options?: RawAxiosRequestConfig,
  ) {
    return MultiselectQuestionsApiFp(this.configuration)
      .retrieve(multiselectQuestionId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Update multiselect question
   * @param {MultiselectQuestionUpdate} multiselectQuestionUpdate
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MultiselectQuestionsApi
   */
  public update(
    multiselectQuestionUpdate: MultiselectQuestionUpdate,
    options?: RawAxiosRequestConfig,
  ) {
    return MultiselectQuestionsApiFp(this.configuration)
      .update(multiselectQuestionUpdate, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * ReservedCommunityTypesApi - axios parameter creator
 * @export
 */
export const ReservedCommunityTypesApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     *
     * @summary Delete reservedCommunityType by id
     * @param {IdDTO} idDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    _delete: async (
      idDTO: IdDTO,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'idDTO' is not null or undefined
      assertParamExists("_delete", "idDTO", idDTO);
      const localVarPath = `/reservedCommunityTypes`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        idDTO,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Create reservedCommunityType
     * @param {ReservedCommunityTypeCreate} reservedCommunityTypeCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    create: async (
      reservedCommunityTypeCreate: ReservedCommunityTypeCreate,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'reservedCommunityTypeCreate' is not null or undefined
      assertParamExists(
        "create",
        "reservedCommunityTypeCreate",
        reservedCommunityTypeCreate,
      );
      const localVarPath = `/reservedCommunityTypes`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        reservedCommunityTypeCreate,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary List reservedCommunityTypes
     * @param {string} [jurisdictionId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    list: async (
      jurisdictionId?: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/reservedCommunityTypes`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (jurisdictionId !== undefined) {
        localVarQueryParameter["jurisdictionId"] = jurisdictionId;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get reservedCommunityType by id
     * @param {string} reservedCommunityTypeId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    retrieve: async (
      reservedCommunityTypeId: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'reservedCommunityTypeId' is not null or undefined
      assertParamExists(
        "retrieve",
        "reservedCommunityTypeId",
        reservedCommunityTypeId,
      );
      const localVarPath =
        `/reservedCommunityTypes/{reservedCommunityTypeId}`.replace(
          `{${"reservedCommunityTypeId"}}`,
          encodeURIComponent(String(reservedCommunityTypeId)),
        );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Update reservedCommunityType
     * @param {ReservedCommunityTypeUpdate} reservedCommunityTypeUpdate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    update: async (
      reservedCommunityTypeUpdate: ReservedCommunityTypeUpdate,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'reservedCommunityTypeUpdate' is not null or undefined
      assertParamExists(
        "update",
        "reservedCommunityTypeUpdate",
        reservedCommunityTypeUpdate,
      );
      const localVarPath = `/reservedCommunityTypes/{reservedCommunityTypeId}`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        reservedCommunityTypeUpdate,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * ReservedCommunityTypesApi - functional programming interface
 * @export
 */
export const ReservedCommunityTypesApiFp = function (
  configuration?: Configuration,
) {
  const localVarAxiosParamCreator =
    ReservedCommunityTypesApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary Delete reservedCommunityType by id
     * @param {IdDTO} idDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async _delete(
      idDTO: IdDTO,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessDTO>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator._delete(
        idDTO,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ReservedCommunityTypesApi._delete"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Create reservedCommunityType
     * @param {ReservedCommunityTypeCreate} reservedCommunityTypeCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async create(
      reservedCommunityTypeCreate: ReservedCommunityTypeCreate,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<ReservedCommunityType>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.create(
        reservedCommunityTypeCreate,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ReservedCommunityTypesApi.create"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary List reservedCommunityTypes
     * @param {string} [jurisdictionId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async list(
      jurisdictionId?: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<Array<ReservedCommunityType>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.list(
        jurisdictionId,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ReservedCommunityTypesApi.list"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Get reservedCommunityType by id
     * @param {string} reservedCommunityTypeId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async retrieve(
      reservedCommunityTypeId: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<ReservedCommunityType>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.retrieve(
        reservedCommunityTypeId,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ReservedCommunityTypesApi.retrieve"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Update reservedCommunityType
     * @param {ReservedCommunityTypeUpdate} reservedCommunityTypeUpdate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async update(
      reservedCommunityTypeUpdate: ReservedCommunityTypeUpdate,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<ReservedCommunityType>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.update(
        reservedCommunityTypeUpdate,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ReservedCommunityTypesApi.update"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * ReservedCommunityTypesApi - factory interface
 * @export
 */
export const ReservedCommunityTypesApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = ReservedCommunityTypesApiFp(configuration);
  return {
    /**
     *
     * @summary Delete reservedCommunityType by id
     * @param {IdDTO} idDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    _delete(idDTO: IdDTO, options?: any): AxiosPromise<SuccessDTO> {
      return localVarFp
        ._delete(idDTO, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Create reservedCommunityType
     * @param {ReservedCommunityTypeCreate} reservedCommunityTypeCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    create(
      reservedCommunityTypeCreate: ReservedCommunityTypeCreate,
      options?: any,
    ): AxiosPromise<ReservedCommunityType> {
      return localVarFp
        .create(reservedCommunityTypeCreate, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary List reservedCommunityTypes
     * @param {string} [jurisdictionId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    list(
      jurisdictionId?: string,
      options?: any,
    ): AxiosPromise<Array<ReservedCommunityType>> {
      return localVarFp
        .list(jurisdictionId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get reservedCommunityType by id
     * @param {string} reservedCommunityTypeId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    retrieve(
      reservedCommunityTypeId: string,
      options?: any,
    ): AxiosPromise<ReservedCommunityType> {
      return localVarFp
        .retrieve(reservedCommunityTypeId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Update reservedCommunityType
     * @param {ReservedCommunityTypeUpdate} reservedCommunityTypeUpdate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    update(
      reservedCommunityTypeUpdate: ReservedCommunityTypeUpdate,
      options?: any,
    ): AxiosPromise<ReservedCommunityType> {
      return localVarFp
        .update(reservedCommunityTypeUpdate, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * ReservedCommunityTypesApi - object-oriented interface
 * @export
 * @class ReservedCommunityTypesApi
 * @extends {BaseAPI}
 */
export class ReservedCommunityTypesApi extends BaseAPI {
  /**
   *
   * @summary Delete reservedCommunityType by id
   * @param {IdDTO} idDTO
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ReservedCommunityTypesApi
   */
  public _delete(idDTO: IdDTO, options?: RawAxiosRequestConfig) {
    return ReservedCommunityTypesApiFp(this.configuration)
      ._delete(idDTO, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Create reservedCommunityType
   * @param {ReservedCommunityTypeCreate} reservedCommunityTypeCreate
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ReservedCommunityTypesApi
   */
  public create(
    reservedCommunityTypeCreate: ReservedCommunityTypeCreate,
    options?: RawAxiosRequestConfig,
  ) {
    return ReservedCommunityTypesApiFp(this.configuration)
      .create(reservedCommunityTypeCreate, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary List reservedCommunityTypes
   * @param {string} [jurisdictionId]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ReservedCommunityTypesApi
   */
  public list(jurisdictionId?: string, options?: RawAxiosRequestConfig) {
    return ReservedCommunityTypesApiFp(this.configuration)
      .list(jurisdictionId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get reservedCommunityType by id
   * @param {string} reservedCommunityTypeId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ReservedCommunityTypesApi
   */
  public retrieve(
    reservedCommunityTypeId: string,
    options?: RawAxiosRequestConfig,
  ) {
    return ReservedCommunityTypesApiFp(this.configuration)
      .retrieve(reservedCommunityTypeId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Update reservedCommunityType
   * @param {ReservedCommunityTypeUpdate} reservedCommunityTypeUpdate
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ReservedCommunityTypesApi
   */
  public update(
    reservedCommunityTypeUpdate: ReservedCommunityTypeUpdate,
    options?: RawAxiosRequestConfig,
  ) {
    return ReservedCommunityTypesApiFp(this.configuration)
      .update(reservedCommunityTypeUpdate, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * RootApi - axios parameter creator
 * @export
 */
export const RootApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     *
     * @summary Trigger the removal of CSVs job
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    clearTempFiles: async (
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/clearTempFiles`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Health check endpoint
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    healthCheck: async (
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Tip me over and pour me out
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    teapot: async (
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/teapot`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * RootApi - functional programming interface
 * @export
 */
export const RootApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = RootApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary Trigger the removal of CSVs job
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async clearTempFiles(
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessDTO>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.clearTempFiles(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["RootApi.clearTempFiles"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Health check endpoint
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async healthCheck(
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessDTO>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.healthCheck(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["RootApi.healthCheck"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Tip me over and pour me out
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async teapot(
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessDTO>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.teapot(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["RootApi.teapot"]?.[localVarOperationServerIndex]
          ?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * RootApi - factory interface
 * @export
 */
export const RootApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = RootApiFp(configuration);
  return {
    /**
     *
     * @summary Trigger the removal of CSVs job
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    clearTempFiles(options?: any): AxiosPromise<SuccessDTO> {
      return localVarFp
        .clearTempFiles(options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Health check endpoint
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    healthCheck(options?: any): AxiosPromise<SuccessDTO> {
      return localVarFp
        .healthCheck(options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Tip me over and pour me out
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    teapot(options?: any): AxiosPromise<SuccessDTO> {
      return localVarFp
        .teapot(options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * RootApi - object-oriented interface
 * @export
 * @class RootApi
 * @extends {BaseAPI}
 */
export class RootApi extends BaseAPI {
  /**
   *
   * @summary Trigger the removal of CSVs job
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RootApi
   */
  public clearTempFiles(options?: RawAxiosRequestConfig) {
    return RootApiFp(this.configuration)
      .clearTempFiles(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Health check endpoint
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RootApi
   */
  public healthCheck(options?: RawAxiosRequestConfig) {
    return RootApiFp(this.configuration)
      .healthCheck(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Tip me over and pour me out
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RootApi
   */
  public teapot(options?: RawAxiosRequestConfig) {
    return RootApiFp(this.configuration)
      .teapot(options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * ScriptRunnerApi - axios parameter creator
 * @export
 */
export const ScriptRunnerApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     *
     * @summary A script that takes in a standardized string and outputs the input for the ami chart create endpoint
     * @param {AmiChartImportDTO} amiChartImportDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    amiChartImport: async (
      amiChartImportDTO: AmiChartImportDTO,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'amiChartImportDTO' is not null or undefined
      assertParamExists(
        "amiChartImport",
        "amiChartImportDTO",
        amiChartImportDTO,
      );
      const localVarPath = `/scriptRunner/amiChartImport`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        amiChartImportDTO,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary An example of how the script runner can work
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    exampleScript: async (
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/scriptRunner/exampleScript`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary A script that adds lottery translations to the db
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    lotteryTranslations: async (
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/scriptRunner/lotteryTranslations`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary A script that adds lottery translations to the db and creates them if it does not exist
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    lotteryTranslations_1: async (
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/scriptRunner/lotteryTranslationsCreateIfEmpty`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary A script that opts out existing lottery listings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    optOutExistingLotteries: async (
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/scriptRunner/optOutExistingLotteries`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary A script that pulls data from one source into the current db
     * @param {DataTransferDTO} dataTransferDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    transferJurisdictionData: async (
      dataTransferDTO: DataTransferDTO,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'dataTransferDTO' is not null or undefined
      assertParamExists(
        "transferJurisdictionData",
        "dataTransferDTO",
        dataTransferDTO,
      );
      const localVarPath = `/scriptRunner/transferJurisdictionData`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        dataTransferDTO,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary A script that pulls data from one source into the current db
     * @param {DataTransferDTO} dataTransferDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    transferJurisdictionListingsData: async (
      dataTransferDTO: DataTransferDTO,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'dataTransferDTO' is not null or undefined
      assertParamExists(
        "transferJurisdictionListingsData",
        "dataTransferDTO",
        dataTransferDTO,
      );
      const localVarPath = `/scriptRunner/transferJurisdictionListingsData`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        dataTransferDTO,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * ScriptRunnerApi - functional programming interface
 * @export
 */
export const ScriptRunnerApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    ScriptRunnerApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary A script that takes in a standardized string and outputs the input for the ami chart create endpoint
     * @param {AmiChartImportDTO} amiChartImportDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async amiChartImport(
      amiChartImportDTO: AmiChartImportDTO,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessDTO>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.amiChartImport(
        amiChartImportDTO,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ScriptRunnerApi.amiChartImport"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary An example of how the script runner can work
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async exampleScript(
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessDTO>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.exampleScript(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ScriptRunnerApi.exampleScript"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary A script that adds lottery translations to the db
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async lotteryTranslations(
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessDTO>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.lotteryTranslations(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ScriptRunnerApi.lotteryTranslations"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary A script that adds lottery translations to the db and creates them if it does not exist
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async lotteryTranslations_1(
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessDTO>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.lotteryTranslations_1(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ScriptRunnerApi.lotteryTranslations_1"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary A script that opts out existing lottery listings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async optOutExistingLotteries(
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessDTO>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.optOutExistingLotteries(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ScriptRunnerApi.optOutExistingLotteries"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary A script that pulls data from one source into the current db
     * @param {DataTransferDTO} dataTransferDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async transferJurisdictionData(
      dataTransferDTO: DataTransferDTO,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessDTO>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.transferJurisdictionData(
          dataTransferDTO,
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ScriptRunnerApi.transferJurisdictionData"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary A script that pulls data from one source into the current db
     * @param {DataTransferDTO} dataTransferDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async transferJurisdictionListingsData(
      dataTransferDTO: DataTransferDTO,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessDTO>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.transferJurisdictionListingsData(
          dataTransferDTO,
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap[
          "ScriptRunnerApi.transferJurisdictionListingsData"
        ]?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * ScriptRunnerApi - factory interface
 * @export
 */
export const ScriptRunnerApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = ScriptRunnerApiFp(configuration);
  return {
    /**
     *
     * @summary A script that takes in a standardized string and outputs the input for the ami chart create endpoint
     * @param {AmiChartImportDTO} amiChartImportDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    amiChartImport(
      amiChartImportDTO: AmiChartImportDTO,
      options?: any,
    ): AxiosPromise<SuccessDTO> {
      return localVarFp
        .amiChartImport(amiChartImportDTO, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary An example of how the script runner can work
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    exampleScript(options?: any): AxiosPromise<SuccessDTO> {
      return localVarFp
        .exampleScript(options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary A script that adds lottery translations to the db
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    lotteryTranslations(options?: any): AxiosPromise<SuccessDTO> {
      return localVarFp
        .lotteryTranslations(options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary A script that adds lottery translations to the db and creates them if it does not exist
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    lotteryTranslations_1(options?: any): AxiosPromise<SuccessDTO> {
      return localVarFp
        .lotteryTranslations_1(options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary A script that opts out existing lottery listings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    optOutExistingLotteries(options?: any): AxiosPromise<SuccessDTO> {
      return localVarFp
        .optOutExistingLotteries(options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary A script that pulls data from one source into the current db
     * @param {DataTransferDTO} dataTransferDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    transferJurisdictionData(
      dataTransferDTO: DataTransferDTO,
      options?: any,
    ): AxiosPromise<SuccessDTO> {
      return localVarFp
        .transferJurisdictionData(dataTransferDTO, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary A script that pulls data from one source into the current db
     * @param {DataTransferDTO} dataTransferDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    transferJurisdictionListingsData(
      dataTransferDTO: DataTransferDTO,
      options?: any,
    ): AxiosPromise<SuccessDTO> {
      return localVarFp
        .transferJurisdictionListingsData(dataTransferDTO, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * ScriptRunnerApi - object-oriented interface
 * @export
 * @class ScriptRunnerApi
 * @extends {BaseAPI}
 */
export class ScriptRunnerApi extends BaseAPI {
  /**
   *
   * @summary A script that takes in a standardized string and outputs the input for the ami chart create endpoint
   * @param {AmiChartImportDTO} amiChartImportDTO
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ScriptRunnerApi
   */
  public amiChartImport(
    amiChartImportDTO: AmiChartImportDTO,
    options?: RawAxiosRequestConfig,
  ) {
    return ScriptRunnerApiFp(this.configuration)
      .amiChartImport(amiChartImportDTO, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary An example of how the script runner can work
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ScriptRunnerApi
   */
  public exampleScript(options?: RawAxiosRequestConfig) {
    return ScriptRunnerApiFp(this.configuration)
      .exampleScript(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary A script that adds lottery translations to the db
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ScriptRunnerApi
   */
  public lotteryTranslations(options?: RawAxiosRequestConfig) {
    return ScriptRunnerApiFp(this.configuration)
      .lotteryTranslations(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary A script that adds lottery translations to the db and creates them if it does not exist
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ScriptRunnerApi
   */
  public lotteryTranslations_1(options?: RawAxiosRequestConfig) {
    return ScriptRunnerApiFp(this.configuration)
      .lotteryTranslations_1(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary A script that opts out existing lottery listings
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ScriptRunnerApi
   */
  public optOutExistingLotteries(options?: RawAxiosRequestConfig) {
    return ScriptRunnerApiFp(this.configuration)
      .optOutExistingLotteries(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary A script that pulls data from one source into the current db
   * @param {DataTransferDTO} dataTransferDTO
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ScriptRunnerApi
   */
  public transferJurisdictionData(
    dataTransferDTO: DataTransferDTO,
    options?: RawAxiosRequestConfig,
  ) {
    return ScriptRunnerApiFp(this.configuration)
      .transferJurisdictionData(dataTransferDTO, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary A script that pulls data from one source into the current db
   * @param {DataTransferDTO} dataTransferDTO
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ScriptRunnerApi
   */
  public transferJurisdictionListingsData(
    dataTransferDTO: DataTransferDTO,
    options?: RawAxiosRequestConfig,
  ) {
    return ScriptRunnerApiFp(this.configuration)
      .transferJurisdictionListingsData(dataTransferDTO, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * UnitAccessibilityPriorityTypesApi - axios parameter creator
 * @export
 */
export const UnitAccessibilityPriorityTypesApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     *
     * @summary Delete unitAccessibilityPriorityType by id
     * @param {IdDTO} idDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    _delete: async (
      idDTO: IdDTO,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'idDTO' is not null or undefined
      assertParamExists("_delete", "idDTO", idDTO);
      const localVarPath = `/unitAccessibilityPriorityTypes`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        idDTO,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Create unitAccessibilityPriorityType
     * @param {UnitAccessibilityPriorityTypeCreate} unitAccessibilityPriorityTypeCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    create: async (
      unitAccessibilityPriorityTypeCreate: UnitAccessibilityPriorityTypeCreate,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'unitAccessibilityPriorityTypeCreate' is not null or undefined
      assertParamExists(
        "create",
        "unitAccessibilityPriorityTypeCreate",
        unitAccessibilityPriorityTypeCreate,
      );
      const localVarPath = `/unitAccessibilityPriorityTypes`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        unitAccessibilityPriorityTypeCreate,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary List unitAccessibilityPriorityTypes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    list: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/unitAccessibilityPriorityTypes`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get unitAccessibilityPriorityType by id
     * @param {string} unitAccessibilityPriorityTypeId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    retrieve: async (
      unitAccessibilityPriorityTypeId: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'unitAccessibilityPriorityTypeId' is not null or undefined
      assertParamExists(
        "retrieve",
        "unitAccessibilityPriorityTypeId",
        unitAccessibilityPriorityTypeId,
      );
      const localVarPath =
        `/unitAccessibilityPriorityTypes/{unitAccessibilityPriorityTypeId}`.replace(
          `{${"unitAccessibilityPriorityTypeId"}}`,
          encodeURIComponent(String(unitAccessibilityPriorityTypeId)),
        );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Update unitAccessibilityPriorityType
     * @param {UnitAccessibilityPriorityTypeUpdate} unitAccessibilityPriorityTypeUpdate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    update: async (
      unitAccessibilityPriorityTypeUpdate: UnitAccessibilityPriorityTypeUpdate,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'unitAccessibilityPriorityTypeUpdate' is not null or undefined
      assertParamExists(
        "update",
        "unitAccessibilityPriorityTypeUpdate",
        unitAccessibilityPriorityTypeUpdate,
      );
      const localVarPath = `/unitAccessibilityPriorityTypes/{unitAccessibilityPriorityTypeId}`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        unitAccessibilityPriorityTypeUpdate,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * UnitAccessibilityPriorityTypesApi - functional programming interface
 * @export
 */
export const UnitAccessibilityPriorityTypesApiFp = function (
  configuration?: Configuration,
) {
  const localVarAxiosParamCreator =
    UnitAccessibilityPriorityTypesApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary Delete unitAccessibilityPriorityType by id
     * @param {IdDTO} idDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async _delete(
      idDTO: IdDTO,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessDTO>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator._delete(
        idDTO,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["UnitAccessibilityPriorityTypesApi._delete"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Create unitAccessibilityPriorityType
     * @param {UnitAccessibilityPriorityTypeCreate} unitAccessibilityPriorityTypeCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async create(
      unitAccessibilityPriorityTypeCreate: UnitAccessibilityPriorityTypeCreate,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<UnitAccessibilityPriorityType>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.create(
        unitAccessibilityPriorityTypeCreate,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["UnitAccessibilityPriorityTypesApi.create"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary List unitAccessibilityPriorityTypes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async list(
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<Array<UnitAccessibilityPriorityType>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.list(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["UnitAccessibilityPriorityTypesApi.list"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Get unitAccessibilityPriorityType by id
     * @param {string} unitAccessibilityPriorityTypeId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async retrieve(
      unitAccessibilityPriorityTypeId: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<UnitAccessibilityPriorityType>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.retrieve(
        unitAccessibilityPriorityTypeId,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["UnitAccessibilityPriorityTypesApi.retrieve"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Update unitAccessibilityPriorityType
     * @param {UnitAccessibilityPriorityTypeUpdate} unitAccessibilityPriorityTypeUpdate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async update(
      unitAccessibilityPriorityTypeUpdate: UnitAccessibilityPriorityTypeUpdate,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<UnitAccessibilityPriorityType>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.update(
        unitAccessibilityPriorityTypeUpdate,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["UnitAccessibilityPriorityTypesApi.update"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * UnitAccessibilityPriorityTypesApi - factory interface
 * @export
 */
export const UnitAccessibilityPriorityTypesApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = UnitAccessibilityPriorityTypesApiFp(configuration);
  return {
    /**
     *
     * @summary Delete unitAccessibilityPriorityType by id
     * @param {IdDTO} idDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    _delete(idDTO: IdDTO, options?: any): AxiosPromise<SuccessDTO> {
      return localVarFp
        ._delete(idDTO, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Create unitAccessibilityPriorityType
     * @param {UnitAccessibilityPriorityTypeCreate} unitAccessibilityPriorityTypeCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    create(
      unitAccessibilityPriorityTypeCreate: UnitAccessibilityPriorityTypeCreate,
      options?: any,
    ): AxiosPromise<UnitAccessibilityPriorityType> {
      return localVarFp
        .create(unitAccessibilityPriorityTypeCreate, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary List unitAccessibilityPriorityTypes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    list(options?: any): AxiosPromise<Array<UnitAccessibilityPriorityType>> {
      return localVarFp
        .list(options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get unitAccessibilityPriorityType by id
     * @param {string} unitAccessibilityPriorityTypeId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    retrieve(
      unitAccessibilityPriorityTypeId: string,
      options?: any,
    ): AxiosPromise<UnitAccessibilityPriorityType> {
      return localVarFp
        .retrieve(unitAccessibilityPriorityTypeId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Update unitAccessibilityPriorityType
     * @param {UnitAccessibilityPriorityTypeUpdate} unitAccessibilityPriorityTypeUpdate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    update(
      unitAccessibilityPriorityTypeUpdate: UnitAccessibilityPriorityTypeUpdate,
      options?: any,
    ): AxiosPromise<UnitAccessibilityPriorityType> {
      return localVarFp
        .update(unitAccessibilityPriorityTypeUpdate, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * UnitAccessibilityPriorityTypesApi - object-oriented interface
 * @export
 * @class UnitAccessibilityPriorityTypesApi
 * @extends {BaseAPI}
 */
export class UnitAccessibilityPriorityTypesApi extends BaseAPI {
  /**
   *
   * @summary Delete unitAccessibilityPriorityType by id
   * @param {IdDTO} idDTO
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UnitAccessibilityPriorityTypesApi
   */
  public _delete(idDTO: IdDTO, options?: RawAxiosRequestConfig) {
    return UnitAccessibilityPriorityTypesApiFp(this.configuration)
      ._delete(idDTO, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Create unitAccessibilityPriorityType
   * @param {UnitAccessibilityPriorityTypeCreate} unitAccessibilityPriorityTypeCreate
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UnitAccessibilityPriorityTypesApi
   */
  public create(
    unitAccessibilityPriorityTypeCreate: UnitAccessibilityPriorityTypeCreate,
    options?: RawAxiosRequestConfig,
  ) {
    return UnitAccessibilityPriorityTypesApiFp(this.configuration)
      .create(unitAccessibilityPriorityTypeCreate, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary List unitAccessibilityPriorityTypes
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UnitAccessibilityPriorityTypesApi
   */
  public list(options?: RawAxiosRequestConfig) {
    return UnitAccessibilityPriorityTypesApiFp(this.configuration)
      .list(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get unitAccessibilityPriorityType by id
   * @param {string} unitAccessibilityPriorityTypeId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UnitAccessibilityPriorityTypesApi
   */
  public retrieve(
    unitAccessibilityPriorityTypeId: string,
    options?: RawAxiosRequestConfig,
  ) {
    return UnitAccessibilityPriorityTypesApiFp(this.configuration)
      .retrieve(unitAccessibilityPriorityTypeId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Update unitAccessibilityPriorityType
   * @param {UnitAccessibilityPriorityTypeUpdate} unitAccessibilityPriorityTypeUpdate
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UnitAccessibilityPriorityTypesApi
   */
  public update(
    unitAccessibilityPriorityTypeUpdate: UnitAccessibilityPriorityTypeUpdate,
    options?: RawAxiosRequestConfig,
  ) {
    return UnitAccessibilityPriorityTypesApiFp(this.configuration)
      .update(unitAccessibilityPriorityTypeUpdate, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * UnitRentTypesApi - axios parameter creator
 * @export
 */
export const UnitRentTypesApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     *
     * @summary Delete unitRentType by id
     * @param {IdDTO} idDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    _delete: async (
      idDTO: IdDTO,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'idDTO' is not null or undefined
      assertParamExists("_delete", "idDTO", idDTO);
      const localVarPath = `/unitRentTypes`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        idDTO,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Create unitRentType
     * @param {UnitRentTypeCreate} unitRentTypeCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    create: async (
      unitRentTypeCreate: UnitRentTypeCreate,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'unitRentTypeCreate' is not null or undefined
      assertParamExists("create", "unitRentTypeCreate", unitRentTypeCreate);
      const localVarPath = `/unitRentTypes`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        unitRentTypeCreate,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary List unitRentTypes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    list: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/unitRentTypes`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get unitRentType by id
     * @param {string} unitRentTypeId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    retrieve: async (
      unitRentTypeId: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'unitRentTypeId' is not null or undefined
      assertParamExists("retrieve", "unitRentTypeId", unitRentTypeId);
      const localVarPath = `/unitRentTypes/{unitRentTypeId}`.replace(
        `{${"unitRentTypeId"}}`,
        encodeURIComponent(String(unitRentTypeId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Update unitRentType
     * @param {UnitRentTypeUpdate} unitRentTypeUpdate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    update: async (
      unitRentTypeUpdate: UnitRentTypeUpdate,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'unitRentTypeUpdate' is not null or undefined
      assertParamExists("update", "unitRentTypeUpdate", unitRentTypeUpdate);
      const localVarPath = `/unitRentTypes/{unitRentTypeId}`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        unitRentTypeUpdate,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * UnitRentTypesApi - functional programming interface
 * @export
 */
export const UnitRentTypesApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    UnitRentTypesApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary Delete unitRentType by id
     * @param {IdDTO} idDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async _delete(
      idDTO: IdDTO,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessDTO>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator._delete(
        idDTO,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["UnitRentTypesApi._delete"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Create unitRentType
     * @param {UnitRentTypeCreate} unitRentTypeCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async create(
      unitRentTypeCreate: UnitRentTypeCreate,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<UnitRentType>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.create(
        unitRentTypeCreate,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["UnitRentTypesApi.create"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary List unitRentTypes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async list(
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<Array<UnitRentType>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.list(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["UnitRentTypesApi.list"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Get unitRentType by id
     * @param {string} unitRentTypeId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async retrieve(
      unitRentTypeId: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<UnitRentType>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.retrieve(
        unitRentTypeId,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["UnitRentTypesApi.retrieve"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Update unitRentType
     * @param {UnitRentTypeUpdate} unitRentTypeUpdate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async update(
      unitRentTypeUpdate: UnitRentTypeUpdate,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<UnitRentType>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.update(
        unitRentTypeUpdate,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["UnitRentTypesApi.update"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * UnitRentTypesApi - factory interface
 * @export
 */
export const UnitRentTypesApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = UnitRentTypesApiFp(configuration);
  return {
    /**
     *
     * @summary Delete unitRentType by id
     * @param {IdDTO} idDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    _delete(idDTO: IdDTO, options?: any): AxiosPromise<SuccessDTO> {
      return localVarFp
        ._delete(idDTO, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Create unitRentType
     * @param {UnitRentTypeCreate} unitRentTypeCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    create(
      unitRentTypeCreate: UnitRentTypeCreate,
      options?: any,
    ): AxiosPromise<UnitRentType> {
      return localVarFp
        .create(unitRentTypeCreate, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary List unitRentTypes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    list(options?: any): AxiosPromise<Array<UnitRentType>> {
      return localVarFp
        .list(options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get unitRentType by id
     * @param {string} unitRentTypeId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    retrieve(
      unitRentTypeId: string,
      options?: any,
    ): AxiosPromise<UnitRentType> {
      return localVarFp
        .retrieve(unitRentTypeId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Update unitRentType
     * @param {UnitRentTypeUpdate} unitRentTypeUpdate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    update(
      unitRentTypeUpdate: UnitRentTypeUpdate,
      options?: any,
    ): AxiosPromise<UnitRentType> {
      return localVarFp
        .update(unitRentTypeUpdate, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * UnitRentTypesApi - object-oriented interface
 * @export
 * @class UnitRentTypesApi
 * @extends {BaseAPI}
 */
export class UnitRentTypesApi extends BaseAPI {
  /**
   *
   * @summary Delete unitRentType by id
   * @param {IdDTO} idDTO
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UnitRentTypesApi
   */
  public _delete(idDTO: IdDTO, options?: RawAxiosRequestConfig) {
    return UnitRentTypesApiFp(this.configuration)
      ._delete(idDTO, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Create unitRentType
   * @param {UnitRentTypeCreate} unitRentTypeCreate
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UnitRentTypesApi
   */
  public create(
    unitRentTypeCreate: UnitRentTypeCreate,
    options?: RawAxiosRequestConfig,
  ) {
    return UnitRentTypesApiFp(this.configuration)
      .create(unitRentTypeCreate, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary List unitRentTypes
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UnitRentTypesApi
   */
  public list(options?: RawAxiosRequestConfig) {
    return UnitRentTypesApiFp(this.configuration)
      .list(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get unitRentType by id
   * @param {string} unitRentTypeId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UnitRentTypesApi
   */
  public retrieve(unitRentTypeId: string, options?: RawAxiosRequestConfig) {
    return UnitRentTypesApiFp(this.configuration)
      .retrieve(unitRentTypeId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Update unitRentType
   * @param {UnitRentTypeUpdate} unitRentTypeUpdate
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UnitRentTypesApi
   */
  public update(
    unitRentTypeUpdate: UnitRentTypeUpdate,
    options?: RawAxiosRequestConfig,
  ) {
    return UnitRentTypesApiFp(this.configuration)
      .update(unitRentTypeUpdate, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * UnitTypesApi - axios parameter creator
 * @export
 */
export const UnitTypesApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     *
     * @summary Delete unitType by id
     * @param {IdDTO} idDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    _delete: async (
      idDTO: IdDTO,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'idDTO' is not null or undefined
      assertParamExists("_delete", "idDTO", idDTO);
      const localVarPath = `/unitTypes`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        idDTO,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Create unitType
     * @param {UnitTypeCreate} unitTypeCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    create: async (
      unitTypeCreate: UnitTypeCreate,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'unitTypeCreate' is not null or undefined
      assertParamExists("create", "unitTypeCreate", unitTypeCreate);
      const localVarPath = `/unitTypes`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        unitTypeCreate,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary List unitTypes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    list: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/unitTypes`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get unitType by id
     * @param {string} unitTypeId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    retrieve: async (
      unitTypeId: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'unitTypeId' is not null or undefined
      assertParamExists("retrieve", "unitTypeId", unitTypeId);
      const localVarPath = `/unitTypes/{unitTypeId}`.replace(
        `{${"unitTypeId"}}`,
        encodeURIComponent(String(unitTypeId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Update unitType
     * @param {UnitTypeUpdate} unitTypeUpdate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    update: async (
      unitTypeUpdate: UnitTypeUpdate,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'unitTypeUpdate' is not null or undefined
      assertParamExists("update", "unitTypeUpdate", unitTypeUpdate);
      const localVarPath = `/unitTypes/{unitTypeId}`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        unitTypeUpdate,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * UnitTypesApi - functional programming interface
 * @export
 */
export const UnitTypesApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    UnitTypesApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary Delete unitType by id
     * @param {IdDTO} idDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async _delete(
      idDTO: IdDTO,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessDTO>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator._delete(
        idDTO,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["UnitTypesApi._delete"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Create unitType
     * @param {UnitTypeCreate} unitTypeCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async create(
      unitTypeCreate: UnitTypeCreate,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<UnitType>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.create(
        unitTypeCreate,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["UnitTypesApi.create"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary List unitTypes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async list(
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<Array<UnitType>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.list(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["UnitTypesApi.list"]?.[localVarOperationServerIndex]
          ?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Get unitType by id
     * @param {string} unitTypeId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async retrieve(
      unitTypeId: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<UnitType>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.retrieve(
        unitTypeId,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["UnitTypesApi.retrieve"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Update unitType
     * @param {UnitTypeUpdate} unitTypeUpdate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async update(
      unitTypeUpdate: UnitTypeUpdate,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<UnitType>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.update(
        unitTypeUpdate,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["UnitTypesApi.update"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * UnitTypesApi - factory interface
 * @export
 */
export const UnitTypesApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = UnitTypesApiFp(configuration);
  return {
    /**
     *
     * @summary Delete unitType by id
     * @param {IdDTO} idDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    _delete(idDTO: IdDTO, options?: any): AxiosPromise<SuccessDTO> {
      return localVarFp
        ._delete(idDTO, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Create unitType
     * @param {UnitTypeCreate} unitTypeCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    create(
      unitTypeCreate: UnitTypeCreate,
      options?: any,
    ): AxiosPromise<UnitType> {
      return localVarFp
        .create(unitTypeCreate, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary List unitTypes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    list(options?: any): AxiosPromise<Array<UnitType>> {
      return localVarFp
        .list(options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get unitType by id
     * @param {string} unitTypeId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    retrieve(unitTypeId: string, options?: any): AxiosPromise<UnitType> {
      return localVarFp
        .retrieve(unitTypeId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Update unitType
     * @param {UnitTypeUpdate} unitTypeUpdate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    update(
      unitTypeUpdate: UnitTypeUpdate,
      options?: any,
    ): AxiosPromise<UnitType> {
      return localVarFp
        .update(unitTypeUpdate, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * UnitTypesApi - object-oriented interface
 * @export
 * @class UnitTypesApi
 * @extends {BaseAPI}
 */
export class UnitTypesApi extends BaseAPI {
  /**
   *
   * @summary Delete unitType by id
   * @param {IdDTO} idDTO
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UnitTypesApi
   */
  public _delete(idDTO: IdDTO, options?: RawAxiosRequestConfig) {
    return UnitTypesApiFp(this.configuration)
      ._delete(idDTO, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Create unitType
   * @param {UnitTypeCreate} unitTypeCreate
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UnitTypesApi
   */
  public create(
    unitTypeCreate: UnitTypeCreate,
    options?: RawAxiosRequestConfig,
  ) {
    return UnitTypesApiFp(this.configuration)
      .create(unitTypeCreate, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary List unitTypes
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UnitTypesApi
   */
  public list(options?: RawAxiosRequestConfig) {
    return UnitTypesApiFp(this.configuration)
      .list(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get unitType by id
   * @param {string} unitTypeId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UnitTypesApi
   */
  public retrieve(unitTypeId: string, options?: RawAxiosRequestConfig) {
    return UnitTypesApiFp(this.configuration)
      .retrieve(unitTypeId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Update unitType
   * @param {UnitTypeUpdate} unitTypeUpdate
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UnitTypesApi
   */
  public update(
    unitTypeUpdate: UnitTypeUpdate,
    options?: RawAxiosRequestConfig,
  ) {
    return UnitTypesApiFp(this.configuration)
      .update(unitTypeUpdate, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * UserApi - axios parameter creator
 * @export
 */
export const UserApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     *
     * @summary Delete user by id
     * @param {IdDTO} idDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    _delete: async (
      idDTO: IdDTO,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'idDTO' is not null or undefined
      assertParamExists("_delete", "idDTO", idDTO);
      const localVarPath = `/user`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        idDTO,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Creates a public only user
     * @param {UserCreate} userCreate
     * @param {boolean} [noWelcomeEmail]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    create: async (
      userCreate: UserCreate,
      noWelcomeEmail?: boolean,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'userCreate' is not null or undefined
      assertParamExists("create", "userCreate", userCreate);
      const localVarPath = `/user`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (noWelcomeEmail !== undefined) {
        localVarQueryParameter["noWelcomeEmail"] = noWelcomeEmail;
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        userCreate,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Forgot Password
     * @param {EmailAndAppUrl} emailAndAppUrl
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    forgotPassword: async (
      emailAndAppUrl: EmailAndAppUrl,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'emailAndAppUrl' is not null or undefined
      assertParamExists("forgotPassword", "emailAndAppUrl", emailAndAppUrl);
      const localVarPath = `/user/forgot-password`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        emailAndAppUrl,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Invite partner user
     * @param {UserInvite} userInvite
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    invite: async (
      userInvite: UserInvite,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'userInvite' is not null or undefined
      assertParamExists("invite", "userInvite", userInvite);
      const localVarPath = `/user/invite`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        userInvite,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Verifies token is valid
     * @param {ConfirmationRequest} confirmationRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    isUserConfirmationTokenValid: async (
      confirmationRequest: ConfirmationRequest,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'confirmationRequest' is not null or undefined
      assertParamExists(
        "isUserConfirmationTokenValid",
        "confirmationRequest",
        confirmationRequest,
      );
      const localVarPath = `/user/is-confirmation-token-valid`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        confirmationRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get a paginated set of users
     * @param {number} [page]
     * @param {number} [limit]
     * @param {Array<UserFilterParams>} [filter]
     * @param {string} [search]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    list: async (
      page?: number,
      limit?: number,
      filter?: Array<UserFilterParams>,
      search?: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/user/list`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (page !== undefined) {
        localVarQueryParameter["page"] = page;
      }

      if (limit !== undefined) {
        localVarQueryParameter["limit"] = limit;
      }

      if (filter) {
        localVarQueryParameter["filter"] = filter;
      }

      if (search !== undefined) {
        localVarQueryParameter["search"] = search;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary List users in CSV
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listAsCsv: async (
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/user/csv`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get a user from cookies
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    profile: async (
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/user`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Request single use code
     * @param {RequestSingleUseCode} requestSingleUseCode
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    requestSingleUseCode: async (
      requestSingleUseCode: RequestSingleUseCode,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'requestSingleUseCode' is not null or undefined
      assertParamExists(
        "requestSingleUseCode",
        "requestSingleUseCode",
        requestSingleUseCode,
      );
      const localVarPath = `/user/request-single-use-code`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        requestSingleUseCode,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Resend public confirmation
     * @param {EmailAndAppUrl} emailAndAppUrl
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    resendConfirmation: async (
      emailAndAppUrl: EmailAndAppUrl,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'emailAndAppUrl' is not null or undefined
      assertParamExists("resendConfirmation", "emailAndAppUrl", emailAndAppUrl);
      const localVarPath = `/user/resend-confirmation`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        emailAndAppUrl,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Resend partner confirmation
     * @param {EmailAndAppUrl} emailAndAppUrl
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    resendPartnerConfirmation: async (
      emailAndAppUrl: EmailAndAppUrl,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'emailAndAppUrl' is not null or undefined
      assertParamExists(
        "resendPartnerConfirmation",
        "emailAndAppUrl",
        emailAndAppUrl,
      );
      const localVarPath = `/user/resend-partner-confirmation`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        emailAndAppUrl,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get user by id
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    retrieve: async (
      id: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("retrieve", "id", id);
      const localVarPath = `/user/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Update user
     * @param {UserUpdate} userUpdate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    update: async (
      userUpdate: UserUpdate,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'userUpdate' is not null or undefined
      assertParamExists("update", "userUpdate", userUpdate);
      const localVarPath = `/user/{id}`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        userUpdate,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * UserApi - functional programming interface
 * @export
 */
export const UserApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = UserApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary Delete user by id
     * @param {IdDTO} idDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async _delete(
      idDTO: IdDTO,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessDTO>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator._delete(
        idDTO,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["UserApi._delete"]?.[localVarOperationServerIndex]
          ?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Creates a public only user
     * @param {UserCreate} userCreate
     * @param {boolean} [noWelcomeEmail]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async create(
      userCreate: UserCreate,
      noWelcomeEmail?: boolean,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.create(
        userCreate,
        noWelcomeEmail,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["UserApi.create"]?.[localVarOperationServerIndex]
          ?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Forgot Password
     * @param {EmailAndAppUrl} emailAndAppUrl
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async forgotPassword(
      emailAndAppUrl: EmailAndAppUrl,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessDTO>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.forgotPassword(
        emailAndAppUrl,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["UserApi.forgotPassword"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Invite partner user
     * @param {UserInvite} userInvite
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async invite(
      userInvite: UserInvite,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.invite(
        userInvite,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["UserApi.invite"]?.[localVarOperationServerIndex]
          ?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Verifies token is valid
     * @param {ConfirmationRequest} confirmationRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async isUserConfirmationTokenValid(
      confirmationRequest: ConfirmationRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessDTO>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.isUserConfirmationTokenValid(
          confirmationRequest,
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["UserApi.isUserConfirmationTokenValid"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Get a paginated set of users
     * @param {number} [page]
     * @param {number} [limit]
     * @param {Array<UserFilterParams>} [filter]
     * @param {string} [search]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async list(
      page?: number,
      limit?: number,
      filter?: Array<UserFilterParams>,
      search?: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<PaginatedUserDto>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.list(
        page,
        limit,
        filter,
        search,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["UserApi.list"]?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary List users in CSV
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listAsCsv(
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.listAsCsv(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["UserApi.listAsCsv"]?.[localVarOperationServerIndex]
          ?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Get a user from cookies
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async profile(
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.profile(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["UserApi.profile"]?.[localVarOperationServerIndex]
          ?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Request single use code
     * @param {RequestSingleUseCode} requestSingleUseCode
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async requestSingleUseCode(
      requestSingleUseCode: RequestSingleUseCode,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessDTO>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.requestSingleUseCode(
          requestSingleUseCode,
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["UserApi.requestSingleUseCode"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Resend public confirmation
     * @param {EmailAndAppUrl} emailAndAppUrl
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async resendConfirmation(
      emailAndAppUrl: EmailAndAppUrl,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessDTO>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.resendConfirmation(
          emailAndAppUrl,
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["UserApi.resendConfirmation"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Resend partner confirmation
     * @param {EmailAndAppUrl} emailAndAppUrl
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async resendPartnerConfirmation(
      emailAndAppUrl: EmailAndAppUrl,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessDTO>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.resendPartnerConfirmation(
          emailAndAppUrl,
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["UserApi.resendPartnerConfirmation"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Get user by id
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async retrieve(
      id: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.retrieve(
        id,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["UserApi.retrieve"]?.[localVarOperationServerIndex]
          ?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Update user
     * @param {UserUpdate} userUpdate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async update(
      userUpdate: UserUpdate,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.update(
        userUpdate,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["UserApi.update"]?.[localVarOperationServerIndex]
          ?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * UserApi - factory interface
 * @export
 */
export const UserApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = UserApiFp(configuration);
  return {
    /**
     *
     * @summary Delete user by id
     * @param {IdDTO} idDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    _delete(idDTO: IdDTO, options?: any): AxiosPromise<SuccessDTO> {
      return localVarFp
        ._delete(idDTO, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Creates a public only user
     * @param {UserCreate} userCreate
     * @param {boolean} [noWelcomeEmail]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    create(
      userCreate: UserCreate,
      noWelcomeEmail?: boolean,
      options?: any,
    ): AxiosPromise<User> {
      return localVarFp
        .create(userCreate, noWelcomeEmail, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Forgot Password
     * @param {EmailAndAppUrl} emailAndAppUrl
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    forgotPassword(
      emailAndAppUrl: EmailAndAppUrl,
      options?: any,
    ): AxiosPromise<SuccessDTO> {
      return localVarFp
        .forgotPassword(emailAndAppUrl, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Invite partner user
     * @param {UserInvite} userInvite
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    invite(userInvite: UserInvite, options?: any): AxiosPromise<User> {
      return localVarFp
        .invite(userInvite, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Verifies token is valid
     * @param {ConfirmationRequest} confirmationRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    isUserConfirmationTokenValid(
      confirmationRequest: ConfirmationRequest,
      options?: any,
    ): AxiosPromise<SuccessDTO> {
      return localVarFp
        .isUserConfirmationTokenValid(confirmationRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get a paginated set of users
     * @param {number} [page]
     * @param {number} [limit]
     * @param {Array<UserFilterParams>} [filter]
     * @param {string} [search]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    list(
      page?: number,
      limit?: number,
      filter?: Array<UserFilterParams>,
      search?: string,
      options?: any,
    ): AxiosPromise<PaginatedUserDto> {
      return localVarFp
        .list(page, limit, filter, search, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary List users in CSV
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listAsCsv(options?: any): AxiosPromise<void> {
      return localVarFp
        .listAsCsv(options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get a user from cookies
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    profile(options?: any): AxiosPromise<User> {
      return localVarFp
        .profile(options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Request single use code
     * @param {RequestSingleUseCode} requestSingleUseCode
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    requestSingleUseCode(
      requestSingleUseCode: RequestSingleUseCode,
      options?: any,
    ): AxiosPromise<SuccessDTO> {
      return localVarFp
        .requestSingleUseCode(requestSingleUseCode, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Resend public confirmation
     * @param {EmailAndAppUrl} emailAndAppUrl
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    resendConfirmation(
      emailAndAppUrl: EmailAndAppUrl,
      options?: any,
    ): AxiosPromise<SuccessDTO> {
      return localVarFp
        .resendConfirmation(emailAndAppUrl, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Resend partner confirmation
     * @param {EmailAndAppUrl} emailAndAppUrl
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    resendPartnerConfirmation(
      emailAndAppUrl: EmailAndAppUrl,
      options?: any,
    ): AxiosPromise<SuccessDTO> {
      return localVarFp
        .resendPartnerConfirmation(emailAndAppUrl, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get user by id
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    retrieve(id: string, options?: any): AxiosPromise<User> {
      return localVarFp
        .retrieve(id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Update user
     * @param {UserUpdate} userUpdate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    update(userUpdate: UserUpdate, options?: any): AxiosPromise<User> {
      return localVarFp
        .update(userUpdate, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
export class UserApi extends BaseAPI {
  /**
   *
   * @summary Delete user by id
   * @param {IdDTO} idDTO
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserApi
   */
  public _delete(idDTO: IdDTO, options?: RawAxiosRequestConfig) {
    return UserApiFp(this.configuration)
      ._delete(idDTO, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Creates a public only user
   * @param {UserCreate} userCreate
   * @param {boolean} [noWelcomeEmail]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserApi
   */
  public create(
    userCreate: UserCreate,
    noWelcomeEmail?: boolean,
    options?: RawAxiosRequestConfig,
  ) {
    return UserApiFp(this.configuration)
      .create(userCreate, noWelcomeEmail, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Forgot Password
   * @param {EmailAndAppUrl} emailAndAppUrl
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserApi
   */
  public forgotPassword(
    emailAndAppUrl: EmailAndAppUrl,
    options?: RawAxiosRequestConfig,
  ) {
    return UserApiFp(this.configuration)
      .forgotPassword(emailAndAppUrl, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Invite partner user
   * @param {UserInvite} userInvite
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserApi
   */
  public invite(userInvite: UserInvite, options?: RawAxiosRequestConfig) {
    return UserApiFp(this.configuration)
      .invite(userInvite, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Verifies token is valid
   * @param {ConfirmationRequest} confirmationRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserApi
   */
  public isUserConfirmationTokenValid(
    confirmationRequest: ConfirmationRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return UserApiFp(this.configuration)
      .isUserConfirmationTokenValid(confirmationRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get a paginated set of users
   * @param {number} [page]
   * @param {number} [limit]
   * @param {Array<UserFilterParams>} [filter]
   * @param {string} [search]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserApi
   */
  public list(
    page?: number,
    limit?: number,
    filter?: Array<UserFilterParams>,
    search?: string,
    options?: RawAxiosRequestConfig,
  ) {
    return UserApiFp(this.configuration)
      .list(page, limit, filter, search, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary List users in CSV
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserApi
   */
  public listAsCsv(options?: RawAxiosRequestConfig) {
    return UserApiFp(this.configuration)
      .listAsCsv(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get a user from cookies
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserApi
   */
  public profile(options?: RawAxiosRequestConfig) {
    return UserApiFp(this.configuration)
      .profile(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Request single use code
   * @param {RequestSingleUseCode} requestSingleUseCode
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserApi
   */
  public requestSingleUseCode(
    requestSingleUseCode: RequestSingleUseCode,
    options?: RawAxiosRequestConfig,
  ) {
    return UserApiFp(this.configuration)
      .requestSingleUseCode(requestSingleUseCode, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Resend public confirmation
   * @param {EmailAndAppUrl} emailAndAppUrl
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserApi
   */
  public resendConfirmation(
    emailAndAppUrl: EmailAndAppUrl,
    options?: RawAxiosRequestConfig,
  ) {
    return UserApiFp(this.configuration)
      .resendConfirmation(emailAndAppUrl, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Resend partner confirmation
   * @param {EmailAndAppUrl} emailAndAppUrl
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserApi
   */
  public resendPartnerConfirmation(
    emailAndAppUrl: EmailAndAppUrl,
    options?: RawAxiosRequestConfig,
  ) {
    return UserApiFp(this.configuration)
      .resendPartnerConfirmation(emailAndAppUrl, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get user by id
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserApi
   */
  public retrieve(id: string, options?: RawAxiosRequestConfig) {
    return UserApiFp(this.configuration)
      .retrieve(id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Update user
   * @param {UserUpdate} userUpdate
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserApi
   */
  public update(userUpdate: UserUpdate, options?: RawAxiosRequestConfig) {
    return UserApiFp(this.configuration)
      .update(userUpdate, options)
      .then((request) => request(this.axios, this.basePath));
  }
}
